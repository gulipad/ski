<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Alpine Ana</title>
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#87ceeb" />
    <meta name="apple-mobile-web-app-title" content="Alpine Ana" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <link rel="apple-touch-icon" href="/assets/images/icon-192.png" />
    <link
      rel="apple-touch-icon"
      sizes="192x192"
      href="/assets/images/icon-192.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="512x512"
      href="/assets/images/icon-512.png"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
    <style>
      /* CSS Reset */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        overflow: hidden;
        background: linear-gradient(to bottom, #87ceeb, #e0f7fa);
        font-family: "Segoe UI", monospace;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }

      /* UI Layer */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 20px;
        opacity: 0;
        transition: opacity 0.5s ease-in;
      }

      #ui-layer.visible {
        opacity: 1;
      }

      #score-board {
        text-align: center;
        color: #333;
        text-shadow: 0 0 2px white;
      }

      #score {
        font-size: 3rem;
        font-weight: 800;
        color: #2c3e50;
      }

      #label {
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: #555;
        font-weight: bold;
      }

      #high-score {
        font-size: 1rem;
        color: #666;
        margin-top: 5px;
        text-shadow: 0 0 2px white;
      }

      #lives {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #2c3e50;
        font-size: 1.5rem;
        font-weight: 800;
        text-shadow: 0 0 2px white;
      }

      #game-over-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        pointer-events: auto;
      }

      #game-over-screen.visible {
        display: flex;
      }

      #game-over-content {
        background: #ffffff;
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        position: relative;
        animation: fadeInUp 0.5s ease-out;
        overflow: visible;
      }

      @media (max-width: 768px) {
        #game-over-content {
          margin: 20px;
          padding: 30px 20px;
          max-width: calc(100% - 40px);
        }
      }

      /* Candy cane border effect */
      #game-over-content::before {
        content: "";
        position: absolute;
        top: -8px;
        left: -8px;
        right: -8px;
        bottom: -8px;
        border-radius: 28px;
        background: repeating-linear-gradient(
          45deg,
          #dc143c 0px,
          #dc143c 20px,
          #ffffff 20px,
          #ffffff 40px
        );
        z-index: -2;
        pointer-events: none;
      }

      #game-over-content::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-radius: 20px;
        background: #ffffff;
        z-index: -1;
        pointer-events: none;
      }

      /* Start Screen */
      #start-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-image: url("/assets/images/bg.webp");
        transition: opacity 0.5s ease-out;
      }

      #start-screen.hidden {
        opacity: 0;
        pointer-events: none;
      }

      /* Mobile background */
      @media (max-width: 768px) {
        #start-screen {
          background-image: url("/assets/images/bg-mobile.webp");
        }
      }

      #start-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 30px;
        padding: 20px;
        text-align: center;
        animation: fadeInUp 1s ease-out;
        position: relative;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      @media (max-width: 768px) {
        #start-content {
          justify-content: flex-start;
          padding-top: 40px;
          gap: 25px;
        }
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      #title-image {
        max-width: 90%;
        width: 600px;
        height: auto;
        filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.3));
        animation: titleFloat 3s ease-in-out infinite;
      }

      @keyframes titleFloat {
        0%,
        100% {
          transform: translateY(0px);
        }
        50% {
          transform: translateY(-10px);
        }
      }

      @media (max-width: 768px) {
        #title-image {
          width: 80%;
          max-width: 400px;
          margin-top: 0;
        }
      }

      #character-image {
        max-width: 250px;
        height: auto;
        filter: drop-shadow(0 8px 20px rgba(0, 0, 0, 0.2));
        position: absolute;
        bottom: 0;
        left: 50px;
        transform: translateX(0);
        z-index: 10;
      }

      @media (max-width: 768px) {
        #character-image {
          max-width: 260px;
          left: 20px;
          transform: translateX(0);
        }
      }

      #start-button {
        background: linear-gradient(135deg, #e8f4f8, #b8d4e3);
        color: #2c3e50;
        border: 3px solid #ffffff;
        padding: 20px 50px;
        font-size: 1.6rem;
        font-weight: bold;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: "Segoe UI", monospace;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2),
          inset 0 2px 10px rgba(255, 255, 255, 0.8),
          0 0 0 2px rgba(255, 255, 255, 0.3);
        text-transform: uppercase;
        letter-spacing: 2px;
        position: relative;
        overflow: hidden;
      }

      #start-button::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: linear-gradient(
          45deg,
          transparent 30%,
          rgba(255, 255, 255, 0.3) 50%,
          transparent 70%
        );
        transform: rotate(45deg);
        transition: all 0.5s ease;
        opacity: 0;
      }

      #start-button:hover::before {
        opacity: 1;
        animation: shimmer 1.5s infinite;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%) translateY(-100%) rotate(45deg);
        }
        100% {
          transform: translateX(100%) translateY(100%) rotate(45deg);
        }
      }

      #start-button:hover {
        background: linear-gradient(135deg, #ffffff, #d4e8f0);
        transform: scale(1.05);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3),
          inset 0 2px 10px rgba(255, 255, 255, 0.9),
          0 0 0 3px rgba(255, 255, 255, 0.5);
        border-color: #ffffff;
      }

      #start-button:active {
        transform: scale(0.98);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2),
          inset 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      #start-button:disabled,
      #start-button.loading {
        cursor: not-allowed;
        opacity: 0.7;
        background: linear-gradient(135deg, #d0d0d0, #b0b0b0);
        pointer-events: none;
      }

      #start-button:disabled:hover,
      #start-button.loading:hover {
        transform: none;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15),
          inset 0 2px 5px rgba(255, 255, 255, 0.5);
      }

      @media (max-width: 768px) {
        #start-button {
          padding: 18px 40px;
          font-size: 1.3rem;
          border-radius: 18px;
        }
      }

      #game-over-title {
        font-size: 3rem;
        font-weight: 900;
        color: #2c3e50;
        margin-bottom: 20px;
      }

      #final-score {
        font-size: 2rem;
        color: #555;
        margin-bottom: 10px;
      }

      #high-score-display {
        font-size: 1.5rem;
        color: #f1c40f;
        margin-bottom: 30px;
        font-weight: bold;
      }

      #retry-button,
      #quit-button,
      #claim-gift-button {
        background: linear-gradient(135deg, #e8f4f8, #b8d4e3);
        color: #2c3e50;
        border: 3px solid #ffffff;
        padding: 15px 40px;
        font-size: 1.2rem;
        font-weight: bold;
        border-radius: 15px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: "Segoe UI", monospace;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2),
          inset 0 2px 8px rgba(255, 255, 255, 0.8),
          0 0 0 2px rgba(255, 255, 255, 0.3);
        text-transform: uppercase;
        letter-spacing: 1px;
        position: relative;
        overflow: hidden;
        margin: 0 10px;
        text-decoration: none;
        display: inline-block;
      }

      #retry-button::before,
      #quit-button::before,
      #claim-gift-button::before {
        content: "";
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: linear-gradient(
          45deg,
          transparent 30%,
          rgba(255, 255, 255, 0.3) 50%,
          transparent 70%
        );
        transform: rotate(45deg);
        transition: all 0.5s ease;
        opacity: 0;
      }

      #retry-button:hover::before,
      #quit-button:hover::before,
      #claim-gift-button:hover::before {
        opacity: 1;
        animation: shimmer 1.5s infinite;
      }

      #retry-button:hover,
      #quit-button:hover,
      #claim-gift-button:hover {
        background: linear-gradient(135deg, #ffffff, #d4e8f0);
        transform: scale(1.05);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3),
          inset 0 2px 10px rgba(255, 255, 255, 0.9),
          0 0 0 3px rgba(255, 255, 255, 0.5);
        border-color: #ffffff;
      }

      #retry-button:active,
      #quit-button:active,
      #claim-gift-button:active {
        transform: scale(0.98);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2),
          inset 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      #game-over-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      @media (max-width: 768px) {
        #retry-button,
        #quit-button,
        #claim-gift-button {
          padding: 14px 35px;
          font-size: 1.1rem;
          border-radius: 12px;
        }
      }

      /* Debug Panel */
      #debug-panel {
        display: none; /* Hidden by default */
        position: absolute;
        top: 10px;
        right: 10px;
        width: 280px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 8px;
        pointer-events: auto;
        font-size: 0.9rem;
        z-index: 100;
        overflow: hidden;
        transition: height 0.3s ease;
      }

      #debug-panel.visible {
        display: block; /* Show when enabled in settings */
      }

      #skier-panel {
        display: none; /* Hidden but kept for functionality */
      }

      #debug-header {
        padding: 15px;
        background: rgba(255, 255, 255, 0.1);
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        user-select: none;
      }

      #debug-header h3 {
        margin: 0;
        color: #f1c40f;
        font-size: 1rem;
      }

      #debug-content {
        padding: 15px;
        display: block;
      }

      #debug-panel.collapsed #debug-content {
        display: none;
      }

      #skier-panel.collapsed #skier-content {
        display: none;
      }

      .control-group {
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .control-group label {
        width: 60px;
      }
      .control-group input {
        width: 140px;
      }
      .control-group span {
        width: 40px;
        text-align: right;
        font-size: 0.8rem;
        color: #ccc;
      }

      #camera-readout {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #555;
        font-size: 0.75rem;
        line-height: 1.4;
        color: #87ceeb;
        user-select: text;
      }

      /* Crash Effect */
      #crash-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: red;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.1s;
        mix-blend-mode: overlay;
      }

      #jump-msg {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #f1c40f;
        font-weight: 900;
        font-size: 2rem;
        text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s;
      }

      /* Settings Menu */
      #settings-button {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 50px;
        height: 50px;
        background: linear-gradient(135deg, #e8f4f8, #b8d4e3);
        border: 3px solid #ffffff;
        border-radius: 12px;
        cursor: pointer;
        pointer-events: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        color: #2c3e50;
        transition: all 0.3s ease;
        z-index: 1000;
        margin-left: -35px;
        opacity: 0;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2),
          inset 0 2px 8px rgba(255, 255, 255, 0.8),
          0 0 0 2px rgba(255, 255, 255, 0.3);
      }

      #settings-button.visible {
        opacity: 1;
      }

      #settings-button:hover {
        background: linear-gradient(135deg, #ffffff, #d4e8f0);
        transform: translateX(-50%) scale(1.1);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3),
          inset 0 2px 10px rgba(255, 255, 255, 0.9),
          0 0 0 3px rgba(255, 255, 255, 0.5);
        border-color: #ffffff;
      }

      /* Pause/Play Button */
      #pause-button {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 50px;
        height: 50px;
        background: linear-gradient(135deg, #e8f4f8, #b8d4e3);
        border: 3px solid #ffffff;
        border-radius: 12px;
        cursor: pointer;
        pointer-events: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        color: #2c3e50;
        transition: all 0.3s ease;
        z-index: 1000;
        margin-left: 35px;
        opacity: 0;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2),
          inset 0 2px 8px rgba(255, 255, 255, 0.8),
          0 0 0 2px rgba(255, 255, 255, 0.3);
      }

      #pause-button.visible {
        opacity: 1;
      }

      #pause-button:hover {
        background: linear-gradient(135deg, #ffffff, #d4e8f0);
        transform: translateX(-50%) scale(1.1);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3),
          inset 0 2px 10px rgba(255, 255, 255, 0.9),
          0 0 0 3px rgba(255, 255, 255, 0.5);
        border-color: #ffffff;
      }

      #settings-menu {
        position: absolute;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(
          135deg,
          rgba(232, 244, 248, 0.98),
          rgba(184, 212, 227, 0.98)
        );
        border: 3px solid #ffffff;
        border-radius: 15px;
        padding: 20px;
        min-width: 200px;
        pointer-events: auto;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 1000;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3),
          inset 0 2px 10px rgba(255, 255, 255, 0.8),
          0 0 0 2px rgba(255, 255, 255, 0.3);
      }

      #settings-menu.visible {
        opacity: 1;
        visibility: visible;
      }

      #settings-menu h3 {
        color: #2c3e50;
        margin: 0 0 15px 0;
        font-size: 1rem;
        text-align: center;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .settings-option {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
        color: #2c3e50;
        font-size: 0.9rem;
      }

      .settings-option:last-child {
        margin-bottom: 0;
      }

      .settings-option label {
        cursor: pointer;
        user-select: none;
        font-weight: 500;
      }

      .settings-option input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
        accent-color: #2c3e50;
      }
    </style>
  </head>
  <body>
    <!-- Start Screen -->
    <div id="start-screen">
      <div id="start-content">
        <img
          id="title-image"
          src="/assets/images/title.webp"
          alt="Alpine Ana"
        />
        <img id="character-image" src="/assets/images/ana.webp" alt="Ana" />
        <button id="start-button">Start Game</button>
      </div>
    </div>

    <div id="crash-overlay"></div>
    <div id="jump-msg">JUMP!</div>

    <!-- Settings Menu -->
    <div id="pause-button" title="Pause">‚è∏Ô∏è</div>
    <div id="settings-button" title="Settings">‚öôÔ∏è</div>
    <div id="settings-menu">
      <h3>Settings</h3>
      <div class="settings-option">
        <label for="music-toggle">Music</label>
        <input type="checkbox" id="music-toggle" checked />
      </div>
      <div class="settings-option">
        <label for="ambient-toggle">Ambient Sound</label>
        <input type="checkbox" id="ambient-toggle" checked />
      </div>
      <div class="settings-option">
        <label for="sfx-toggle">Sound Effects</label>
        <input type="checkbox" id="sfx-toggle" checked />
      </div>
      <div class="settings-option">
        <label for="camera-controls-toggle">Camera Controls</label>
        <input type="checkbox" id="camera-controls-toggle" />
      </div>
    </div>

    <!-- Camera Debug Panel -->
    <div id="debug-panel" class="collapsed">
      <!-- Default to collapsed -->
      <div id="debug-header">
        <h3>Camera Controls</h3>
        <span id="toggle-icon">‚ñº</span>
      </div>
      <div id="debug-content">
        <div class="control-group">
          <label>Pos Y</label>
          <input type="range" id="camY" min="50" max="200" step="1" />
          <span id="valY">0</span>
        </div>
        <div class="control-group">
          <label>Pos Z</label>
          <input type="range" id="camZ" min="0" max="100" step="1" />
          <span id="valZ">0</span>
        </div>

        <hr style="border: 0; border-top: 1px solid #555; margin: 10px 0" />

        <div class="control-group">
          <label>Look Y</label>
          <input type="range" id="lookY" min="0" max="150" step="1" />
          <span id="valLookY">0</span>
        </div>
        <div class="control-group">
          <label>Look Z</label>
          <input type="range" id="lookZ" min="-50" max="50" step="1" />
          <span id="valLookZ">0</span>
        </div>

        <div class="control-group">
          <label>FOV</label>
          <input type="range" id="camFov" min="10" max="120" step="1" />
          <span id="valFov">0</span>
        </div>

        <div id="camera-readout">Values will appear here...</div>
      </div>
    </div>

    <!-- Skier Debug Panel -->
    <div id="skier-panel">
      <div id="skier-header">
        <h3>Skier Controls</h3>
        <span id="skier-toggle-icon">‚ñ≤</span>
      </div>
      <div id="skier-content">
        <div class="control-group">
          <label>Scale</label>
          <input type="range" id="skierScale" min="0.5" max="10" step="0.1" />
          <span id="valSkierScale">3.0</span>
        </div>

        <hr style="border: 0; border-top: 1px solid #555; margin: 10px 0" />

        <div class="control-group">
          <label>Pos X</label>
          <input type="range" id="skierX" min="-5" max="5" step="0.1" />
          <span id="valSkierX">0</span>
        </div>
        <div class="control-group">
          <label>Pos Y</label>
          <input type="range" id="skierY" min="-5" max="5" step="0.1" />
          <span id="valSkierY">0</span>
        </div>
        <div class="control-group">
          <label>Pos Z</label>
          <input type="range" id="skierZ" min="-5" max="5" step="0.1" />
          <span id="valSkierZ">0</span>
        </div>

        <hr style="border: 0; border-top: 1px solid #555; margin: 10px 0" />

        <div class="control-group">
          <label>Rot X</label>
          <input
            type="range"
            id="skierRotX"
            min="-3.14"
            max="3.14"
            step="0.1"
          />
          <span id="valSkierRotX">0</span>
        </div>
        <div class="control-group">
          <label>Rot Y</label>
          <input
            type="range"
            id="skierRotY"
            min="-3.14"
            max="3.14"
            step="0.1"
          />
          <span id="valSkierRotY">0</span>
        </div>
        <div class="control-group">
          <label>Rot Z</label>
          <input
            type="range"
            id="skierRotZ"
            min="-3.14"
            max="3.14"
            step="0.1"
          />
          <span id="valSkierRotZ">0</span>
        </div>

        <div
          id="skier-readout"
          style="
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #555;
            font-size: 0.75rem;
            line-height: 1.4;
            color: #87ceeb;
            user-select: text;
          "
        >
          Values will appear here...
        </div>

        <div
          id="bone-controls"
          style="
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #555;
            display: none;
          "
        >
          <div
            style="
              font-size: 0.85rem;
              color: #f1c40f;
              margin-bottom: 10px;
              font-weight: bold;
            "
          >
            Bone Controls
          </div>
          <button
            id="apply-skiing-pose"
            style="
              width: 100%;
              padding: 8px;
              margin-bottom: 10px;
              background: #27ae60;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: bold;
            "
          >
            Apply Skiing Pose
          </button>
          <div id="bone-controls-content"></div>
        </div>
      </div>
    </div>

    <div id="ui-layer">
      <div id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
      <div id="score-board">
        <div id="score">0</div>
        <div id="label">Meters</div>
        <div id="high-score">Best: 0</div>
      </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen">
      <div id="game-over-content">
        <div id="game-over-title">Game Over</div>
        <div id="final-score">
          Distance: <span id="final-score-value">0</span>m
        </div>
        <div id="high-score-display">
          Best: <span id="high-score-value">0</span>m
        </div>
        <div id="game-over-buttons">
          <button id="retry-button">Retry</button>
          <button id="quit-button">Quit</button>
          <a
            id="claim-gift-button"
            href="https://www.instagram.com/p/DRj55uzCC65/"
            target="_blank"
            rel="noopener noreferrer"
            style="display: none"
            >Claim gift üéÅ</a
          >
        </div>
      </div>
    </div>

    <script>
      // --- CONFIGURATION ---
      const CONFIG = {
        baseSpeed: 0.003,
        maxSpeed: 0.006, // Maximum speed (2x base speed)
        accelerationRate: 0.000001, // Very slight acceleration per frame
        turnSpeed: 0.25,
        worldRadius: 100,
        spawnInterval: 0.18,
        boundaryInterval: 0.08,
        laneWidth: 5,
        gravity: 0.06, // Slightly higher gravity for snappier jumps
        jumpStrength: 0.7, // Lower jump height
        fogColor: 0x87ceeb,
        treeVerticalOffset: 3, // Vertical offset for playing trees (adjustable)
        giftVerticalOffset: 2, // Vertical offset for gift
        groundColor: 0xffffff,
      };

      // --- GLOBAL VARIABLES ---
      let scene, camera, renderer;
      let player, playerGroup;
      let worldSphere;

      // Animation
      let mixer;
      let clock = new THREE.Clock();
      let skierModel;
      let skierBaseOffset = { x: 0, y: 0, z: 0 };
      let skierBones = {}; // Store bone references for manipulation

      // Subtle animation state for natural movement
      let animationTime = 0;
      let animationParams = {
        pelvis: { baseY: 0, amplitude: 0.19 },
        waist: { baseY: 0, amplitude: 0.2 },
        head: { baseY: -0.47, amplitude: 0.19 },
      };
      const animationSpeed = 1.9;

      // Jump animation state
      let jumpAnimationSpeed = 1.0;
      let jumpAnimationParams = {
        lUpperarmZ: -0.12,
        rUpperarmZ: 0.02,
        lThighY: -0.42,
        rThighY: 0.63,
      };
      let jumpAnimationTime = 0;
      let lUpperarmBaseZ = 0;
      let rUpperarmBaseZ = 0;
      let lThighBaseY = 0;
      let rThighBaseY = 0;

      // Turn animation state
      let rightTurnSpeed = 1.0;
      let rightTurnParams = {
        pelvisY: -1.02,
        headY: 0.13,
      };
      let rightTurnBaseValues = { pelvisY: 0, headY: 0 };
      let isRightTurning = false;
      let rightTurnTime = 0;

      let leftTurnSpeed = 1.0;
      let leftTurnParams = {
        pelvisY: -0.02,
        headY: -0.87,
      };
      let leftTurnBaseValues = { pelvisY: 0, headY: 0 };
      let isLeftTurning = false;
      let leftTurnTime = 0;

      // Crash animation state
      let crashAnimationSpeed = 1.25;
      let crashAnimationParams = {
        pelvisZ: -3.14,
        hipX: 1.53,
        hipY: -0.97,
        hipZ: 0.83,
        lThighY: 0.28,
        lThighZ: 1.33,
        rThighY: -0.27,
        rThighZ: 1.33,
        headZ: 0.88,
        rHandY: -1.57,
        lHandY: 1.53,
      };
      let crashBaseValues = {
        pelvisZ: 0,
        hipX: 0,
        hipY: 0,
        hipZ: 0,
        lThighY: 0,
        lThighZ: 0,
        rThighY: 0,
        rThighZ: 0,
        headZ: 0,
        rHandY: 0,
        lHandY: 0,
      };
      let isCrashing = false;
      let crashTime = 0;

      let gameActive = false; // Start as false until start button is clicked
      let isPaused = false;
      let lives = 3;
      let isGameOver = false;
      let skierRollAwayRotation = 0;
      let crashCooldown = false; // Prevent multiple crashes in quick succession
      let crashCooldownTimeout = null; // Store timeout ID to clear it on restart
      let gameStarted = false; // Track if game has been started
      let bonesDirty = false; // Track if bones need skeleton update
      let wasJumping = false; // Track previous jump state to detect jump end

      // Asset loading tracker
      const assetLoadingState = {
        skier: false,
        tree: false,
        rock: false,
        redSign: false,
        blueSign: false,
        fence: false,
        gift: false,
      };

      function checkAllAssetsLoaded() {
        const allLoaded = Object.values(assetLoadingState).every(
          (loaded) => loaded === true
        );
        if (allLoaded) {
          const startButton = document.getElementById("start-button");
          if (startButton) {
            startButton.disabled = false;
            startButton.textContent = "Start Game";
            startButton.classList.remove("loading");
          }
        }
      }

      function updateLoadingProgress() {
        const loadedCount = Object.values(assetLoadingState).filter(
          (loaded) => loaded === true
        ).length;
        const totalCount = Object.keys(assetLoadingState).length;
        const percentage = Math.round((loadedCount / totalCount) * 100);
        const startButton = document.getElementById("start-button");
        if (startButton && startButton.disabled) {
          startButton.textContent = `Loading Assets... ${percentage}%`;
        }
      }

      // Audio system
      let musicEnabled = true;
      let ambientEnabled = true;
      let sfxEnabled = true;

      // ---------- AUDIO MANAGER (WebAudio SFX + HTMLAudio loops) ----------
      class AudioManager {
        constructor({ soundManifest, volumes }) {
          this.soundManifest = soundManifest; // key -> url
          this.volumes = volumes; // key -> 0..1

          this.ctx = null;
          this.buffers = new Map();

          this.musicEnabled = true;
          this.ambientEnabled = true;
          this.sfxEnabled = true;

          // loops as HTMLAudio (streaming)
          this.music = new Audio("/assets/audio/music.mp3");
          this.music.loop = true;
          this.music.preload = "auto";
          this.music.playsInline = true;
          this.music.volume = 0.5;

          this.ambient = new Audio("/assets/audio/snow-sliding.mp3");
          this.ambient.loop = true;
          this.ambient.preload = "auto";
          this.ambient.playsInline = true;
          this.ambient.volume = 0.6;

          this.unlocked = false;
        }

        async unlock() {
          if (this.unlocked) return;

          // Create AudioContext on gesture
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          if (this.ctx.state === "suspended") {
            await this.ctx.resume().catch(() => {});
          }

          // Load/decode SFX buffers
          await this._loadAllSfx();

          // Prime loops so iOS "authorizes" them
          await this._primeHtmlAudio(this.music);
          await this._primeHtmlAudio(this.ambient);

          this.unlocked = true;

          // Start loops if enabled
          this.ensureMusic();
          this.ensureAmbient({
            gameActive: true,
            isPaused: false,
            isGameOver: false,
            isJumping: false,
          });
        }

        async _loadAllSfx() {
          const entries = Object.entries(this.soundManifest);

          // Only load SFX here (exclude music/ambient if present in manifest)
          const sfxEntries = entries.filter(
            ([key]) => key !== "music" && key !== "ambient"
          );

          await Promise.all(
            sfxEntries.map(async ([key, url]) => {
              try {
                const res = await fetch(url);
                const arr = await res.arrayBuffer();
                const buf = await this.ctx.decodeAudioData(arr);
                this.buffers.set(key, buf);
              } catch (e) {
                console.warn("Failed to load SFX", key, url, e);
              }
            })
          );
        }

        async _primeHtmlAudio(a) {
          try {
            a.muted = true;
            await a.play();
            a.pause();
            a.currentTime = 0;
            a.muted = false;
          } catch {
            // okay if it fails on some devices; unlock gesture usually helps
          }
        }

        setToggles({ musicEnabled, ambientEnabled, sfxEnabled }) {
          if (typeof musicEnabled === "boolean")
            this.musicEnabled = musicEnabled;
          if (typeof ambientEnabled === "boolean")
            this.ambientEnabled = ambientEnabled;
          if (typeof sfxEnabled === "boolean") this.sfxEnabled = sfxEnabled;

          // Apply immediately
          this.ensureMusic();
          // ambient depends on game state; call ensureAmbient from your game loop/state transitions
        }

        // ---- SFX (WebAudio) ----
        playSfx(key) {
          if (!this.unlocked || !this.ctx || !this.sfxEnabled) return;

          const buf = this.buffers.get(key);
          if (!buf) return;

          const src = this.ctx.createBufferSource();
          src.buffer = buf;

          const gain = this.ctx.createGain();
          gain.gain.value = this.volumes[key] ?? 0.7;

          src.connect(gain);
          gain.connect(this.ctx.destination);

          src.start(0);
        }

        // ---- Loops (HTMLAudio) ----
        ensureMusic() {
          if (!this.unlocked) return;
          if (!this.musicEnabled) {
            if (!this.music.paused) this.music.pause();
            return;
          }
          if (this.music.paused) this.music.play().catch(() => {});
        }

        ensureAmbient({ gameActive, isPaused, isGameOver, isJumping }) {
          if (!this.unlocked) return;

          const shouldPlay =
            this.ambientEnabled &&
            gameActive &&
            !isPaused &&
            !isGameOver &&
            !isJumping;

          if (shouldPlay) {
            if (this.ambient.paused) this.ambient.play().catch(() => {});
          } else {
            if (!this.ambient.paused) this.ambient.pause();
          }
        }

        stopAll() {
          if (!this.music.paused) this.music.pause();
          if (!this.ambient.paused) this.ambient.pause();
        }
      }
      // ---------- end AUDIO MANAGER ----------

      // SFX volumes map
      const SFX_VOLUMES = {
        jump: 0.6,
        crash: 0.7,
        leftTurn: 0.4,
        rightTurn: 0.4,
        ouch3: 0.7,
        thump: 0.6,
        ohNo: 0.7,
        twinkle: 0.8,
      };

      // Register sounds to load (SFX only - music/ambient handled separately)
      const soundManifest = {
        jump: "/assets/audio/jump.mp3",
        crash: "/assets/audio/crash.mp3",
        leftTurn: "/assets/audio/turn.mp3",
        rightTurn: "/assets/audio/turn.mp3", // Same file
        ouch3: "/assets/audio/ouch_3.mp3",
        thump: "/assets/audio/thump.mp3",
        ohNo: "/assets/audio/oh_no.mp3",
        twinkle: "/assets/audio/twinkle.mp3",
      };

      // Create audio manager instance
      const audio = new AudioManager({
        soundManifest,
        volumes: SFX_VOLUMES,
      });

      // Cookie helper functions
      function setCookie(name, value, days = 365) {
        const expires = new Date();
        expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
        document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
      }

      function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(";");
        for (let i = 0; i < ca.length; i++) {
          let c = ca[i];
          while (c.charAt(0) === " ") c = c.substring(1, c.length);
          if (c.indexOf(nameEQ) === 0)
            return c.substring(nameEQ.length, c.length);
        }
        return null;
      }

      // Load audio settings from cookies
      function loadAudioSettings() {
        const musicCookie = getCookie("musicEnabled");
        const ambientCookie = getCookie("ambientEnabled");
        const sfxCookie = getCookie("sfxEnabled");

        if (musicCookie !== null) {
          musicEnabled = musicCookie === "true";
        }
        if (ambientCookie !== null) {
          ambientEnabled = ambientCookie === "true";
        }
        if (sfxCookie !== null) {
          sfxEnabled = sfxCookie === "true";
        }

        // Update UI
        document.getElementById("music-toggle").checked = musicEnabled;
        document.getElementById("ambient-toggle").checked = ambientEnabled;
        document.getElementById("sfx-toggle").checked = sfxEnabled;

        // Apply settings to AudioManager
        audio.setToggles({ musicEnabled, ambientEnabled, sfxEnabled });
      }

      // Save audio settings to cookies
      function saveAudioSettings() {
        setCookie("musicEnabled", musicEnabled);
        setCookie("ambientEnabled", ambientEnabled);
        setCookie("sfxEnabled", sfxEnabled);
      }

      // Old audio code removed - using AudioManager now

      // Camera controls visibility state
      let cameraControlsEnabled = false;

      // Load camera controls preference
      function loadCameraControlsSetting() {
        const saved = getCookie("cameraControlsEnabled");
        cameraControlsEnabled = saved === "true";
        const debugPanel = document.getElementById("debug-panel");
        const cameraToggle = document.getElementById("camera-controls-toggle");
        if (debugPanel) {
          if (cameraControlsEnabled) {
            debugPanel.classList.add("visible");
          } else {
            debugPanel.classList.remove("visible");
          }
        }
        if (cameraToggle) {
          cameraToggle.checked = cameraControlsEnabled;
        }
      }

      // Save camera controls preference
      function saveCameraControlsSetting() {
        setCookie("cameraControlsEnabled", cameraControlsEnabled.toString());
      }

      // Settings menu toggle
      function setupSettingsMenu() {
        const settingsButton = document.getElementById("settings-button");
        const settingsMenu = document.getElementById("settings-menu");
        const musicToggle = document.getElementById("music-toggle");
        const ambientToggle = document.getElementById("ambient-toggle");
        const sfxToggle = document.getElementById("sfx-toggle");
        const cameraControlsToggle = document.getElementById(
          "camera-controls-toggle"
        );

        settingsButton.addEventListener("click", () => {
          settingsMenu.classList.toggle("visible");
        });

        // Close menu when clicking outside
        document.addEventListener("click", (e) => {
          if (
            !settingsMenu.contains(e.target) &&
            !settingsButton.contains(e.target)
          ) {
            settingsMenu.classList.remove("visible");
          }
        });

        // Music toggle
        musicToggle.addEventListener("change", (e) => {
          musicEnabled = e.target.checked;
          saveAudioSettings();
          audio.setToggles({ musicEnabled });
        });

        // Ambient toggle
        ambientToggle.addEventListener("change", (e) => {
          ambientEnabled = e.target.checked;
          saveAudioSettings();
          audio.setToggles({ ambientEnabled });
          audio.ensureAmbient({ gameActive, isPaused, isGameOver, isJumping });
        });

        // SFX toggle (controls only sound effects, not ambient)
        sfxToggle.addEventListener("change", (e) => {
          sfxEnabled = e.target.checked;
          saveAudioSettings();
          audio.setToggles({ sfxEnabled });
        });

        // Camera controls toggle
        if (cameraControlsToggle) {
          cameraControlsToggle.addEventListener("change", (e) => {
            cameraControlsEnabled = e.target.checked;
            saveCameraControlsSetting();
            const debugPanel = document.getElementById("debug-panel");
            if (debugPanel) {
              if (cameraControlsEnabled) {
                debugPanel.classList.add("visible");
              } else {
                debugPanel.classList.remove("visible");
              }
            }
          });
        }
      }
      let score = 0;
      let highScore = 0;

      // Load high score from localStorage
      function loadHighScore() {
        const stored = localStorage.getItem("skiGameHighScore");
        if (stored !== null) {
          highScore = parseInt(stored, 10);
          updateHighScoreDisplay();
        }
      }

      // Save high score to localStorage
      function saveHighScore() {
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("skiGameHighScore", highScore.toString());
          updateHighScoreDisplay();
        }
      }

      // Update high score display
      function updateHighScoreDisplay() {
        const highScoreElement = document.getElementById("high-score");
        if (highScoreElement) {
          highScoreElement.textContent = `Best: ${Math.floor(highScore)}m`;
        }
        const highScoreValueElement =
          document.getElementById("high-score-value");
        if (highScoreValueElement) {
          highScoreValueElement.textContent = Math.floor(highScore);
        }
      }

      // Update lives display
      function updateLivesDisplay() {
        const livesElement = document.getElementById("lives");
        if (livesElement) {
          const hearts = "‚ù§Ô∏è".repeat(lives) + "ü§ç".repeat(3 - lives);
          livesElement.textContent = hearts;
        }
      }
      let currentRotationSpeed = CONFIG.baseSpeed;

      let currentLane = 0;
      let targetX = 0;

      let isJumping = false;
      let verticalVelocity = 0;
      let playerHeight = 0;

      let lastSpawnRotation = 0;
      let lastBoundaryRotation = 0;
      let boundaryAlternator = 0;

      let activeObstacles = [];
      let activeBarriers = [];
      let activeBoundaries = [];
      let activeGift = null; // Only one gift at a time
      let giftCollected = false; // Track if gift has been collected
      let lastGiftSpawnDistance = 0; // Track distance when last gift was spawned
      let collisionCheckCounter = 0; // Counter for mobile collision optimization
      let animationFrameCounter = 0; // Counter for mobile animation optimization
      let cleanupCounter = 0; // Counter for mobile cleanup optimization

      // Reusable objects to prevent memory leaks (created once, reused every frame)
      const _tempEuler = new THREE.Euler(0, 0, 0, "XYZ");
      const _tempVec3 = new THREE.Vector3();
      const _tempMatrix = new THREE.Matrix4();
      const _tempPos = new THREE.Vector3();
      const _tempQuat = new THREE.Quaternion();
      const _tempScale = new THREE.Vector3();
      const _tempEulerInst = new THREE.Euler();

      // Instanced rendering helpers
      function findFirstMesh(root) {
        let found = null;
        root.traverse((o) => {
          if (!found && o.isMesh) found = o;
        });
        return found;
      }

      function createInstancerFromGLB(glbScene, maxCount) {
        const mesh = findFirstMesh(glbScene);
        if (!mesh) throw new Error("No mesh found in GLB");

        const inst = new THREE.InstancedMesh(
          mesh.geometry,
          mesh.material,
          maxCount
        );
        inst.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        return inst;
      }

      // Instanced mesh variables
      let treeInstances = null;
      let rockInstances = null;
      let redSignInstances = null;
      let blueSignInstances = null;
      let fenceInstances = null;

      // ID allocation/recycling for instanced objects
      const freeTreeIds = [];
      const freeRockIds = [];
      const freeRedSignIds = [];
      const freeBlueSignIds = [];
      const freeFenceIds = [];
      let nextTreeId = 0;
      let nextRockId = 0;
      let nextRedSignId = 0;
      let nextBlueSignId = 0;
      let nextFenceId = 0;

      function allocTreeId() {
        return freeTreeIds.length ? freeTreeIds.pop() : nextTreeId++;
      }
      function allocRockId() {
        return freeRockIds.length ? freeRockIds.pop() : nextRockId++;
      }
      function allocRedSignId() {
        return freeRedSignIds.length ? freeRedSignIds.pop() : nextRedSignId++;
      }
      function allocBlueSignId() {
        return freeBlueSignIds.length
          ? freeBlueSignIds.pop()
          : nextBlueSignId++;
      }
      function allocFenceId() {
        return freeFenceIds.length ? freeFenceIds.pop() : nextFenceId++;
      }

      function setOnSphereInstance(
        instancedMesh,
        id,
        angle,
        xOffset,
        scale,
        yRot,
        isDecoration = false,
        yOffset = 0,
        isTree = false
      ) {
        const R = CONFIG.worldRadius;
        const y = R * Math.cos(angle);
        const z = R * Math.sin(angle);

        _tempPos.set(xOffset, y, z);

        // Apply vertical offset for playing trees only (not decoration trees, not rocks/signs/fences)
        if (isTree && !isDecoration && CONFIG.treeVerticalOffset !== 0) {
          const normalY = Math.cos(angle);
          const normalZ = Math.sin(angle);
          _tempPos.y += CONFIG.treeVerticalOffset * normalY;
          _tempPos.z += CONFIG.treeVerticalOffset * normalZ;
        }

        // Apply additional Y offset (for signs/fences)
        if (yOffset !== 0) {
          _tempPos.y += yOffset;
        }

        // Match placeOnSphere: rotation.x = angle + random Y rotation
        _tempEulerInst.set(angle, yRot, 0, "XYZ");
        _tempQuat.setFromEuler(_tempEulerInst);

        _tempScale.set(scale, scale, scale);

        _tempMatrix.compose(_tempPos, _tempQuat, _tempScale);
        instancedMesh.setMatrixAt(id, _tempMatrix);
      }

      // Object pools for reusing objects instead of creating/destroying them (DEPRECATED - using instancing now)
      const treePool = [];
      const rockPool = [];
      const fencePool = [];
      const signPool = [];

      // Limit max active objects on mobile for better performance
      const MAX_ACTIVE_OBSTACLES = isMobile() ? 20 : 50;
      const MAX_ACTIVE_BARRIERS = isMobile() ? 10 : 30;

      // Detect mobile device
      function isMobile() {
        return (
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ) || window.innerWidth <= 768
        );
      }

      // Camera State (User Values applied here)
      let camParams = isMobile()
        ? {
            y: 109,
            z: 34,
            lookY: 66,
            lookZ: -50,
            fov: 77,
          }
        : {
            y: 114,
            z: 42,
            lookY: 92,
            lookZ: -9,
            fov: 38,
          };

      // Skier Transform State
      let skierParams = {
        scale: isMobile() ? 5.5 : 4.4, // Larger scale on mobile for better visibility
        posX: -0.2,
        posY: 0.6,
        posZ: -0.3,
        rotX: 0.06,
        rotY: 3.06,
        rotZ: -0.04,
      };

      // Bone rotation state
      let boneParams = {};

      // --- HELPER: TEXTURES ---
      // --- MOBILE OPTIMIZATION HELPER ---
      function optimizeModelForMobile(sceneObject) {
        if (!isMobile()) return; // Keep high quality on desktop

        sceneObject.traverse((child) => {
          if (child.isMesh && child.material) {
            // Create a cheaper material preserving the color/map
            const oldMat = child.material;
            const newMat = new THREE.MeshLambertMaterial({
              map: oldMat.map,
              color: oldMat.color,
              // PERFORMANCE SAVER: Force alphaTest to discard transparent pixels immediately
              // 0.5 means "if it's more than 50% see-through, don't draw it at all"
              alphaTest: 0.5,
              // Force transparency OFF so the GPU treats it as a solid wall (faster)
              transparent: false,
              side: oldMat.side,
            });

            // Dispose old material to free memory
            // oldMat.dispose(); // Optional: be careful if materials are shared
            child.material = newMat;
            child.material.needsUpdate = true;
          }
        });
      }

      // --- START SCREEN ---
      async function startGame() {
        // Unlock audio on Start button tap (iOS requirement)
        await audio.unlock();

        const startScreen = document.getElementById("start-screen");
        if (startScreen) {
          startScreen.classList.add("hidden");

          // Wait for fade out animation before starting game
          setTimeout(() => {
            startScreen.style.display = "none";
          }, 500);
        }

        // Show game UI elements
        const uiLayer = document.getElementById("ui-layer");
        if (uiLayer) {
          uiLayer.classList.add("visible");
        }

        const settingsButton = document.getElementById("settings-button");
        if (settingsButton) {
          settingsButton.classList.add("visible");
        }

        const pauseButton = document.getElementById("pause-button");
        if (pauseButton) {
          pauseButton.classList.add("visible");
        }

        // Reset gift state for new game
        if (activeGift) {
          worldSphere.remove(activeGift.mesh);
        }
        activeGift = null;
        giftCollected = false;
        lastGiftSpawnDistance = 0;

        // Reset score for new game
        score = 0;
        document.getElementById("score").innerText = "0";

        // Reset lives for new game
        lives = 3;
        updateLivesDisplay();

        // Start the game
        gameActive = true;
        gameStarted = true;

        // Start music and ambient sound when game starts
        audio.ensureMusic();
        audio.ensureAmbient({ gameActive, isPaused, isGameOver, isJumping });
      }

      function quitGame() {
        // Hide game over screen
        const gameOverScreen = document.getElementById("game-over-screen");
        if (gameOverScreen) {
          gameOverScreen.classList.remove("visible");
        }

        // Show start screen
        const startScreen = document.getElementById("start-screen");
        if (startScreen) {
          startScreen.style.display = "flex";
          startScreen.classList.remove("hidden");
        }

        // Hide game UI elements
        const uiLayer = document.getElementById("ui-layer");
        if (uiLayer) {
          uiLayer.classList.remove("visible");
        }

        const settingsButton = document.getElementById("settings-button");
        if (settingsButton) {
          settingsButton.classList.remove("visible");
        }

        const pauseButton = document.getElementById("pause-button");
        if (pauseButton) {
          pauseButton.classList.remove("visible");
        }

        // Reset gift state
        if (activeGift) {
          worldSphere.remove(activeGift.mesh);
        }
        activeGift = null;
        giftCollected = false;
        lastGiftSpawnDistance = 0;

        // Reset game state
        gameActive = false;
        gameStarted = false;
        isGameOver = false;
        isPaused = false;

        // Reset lives for next game
        lives = 3;
        updateLivesDisplay();

        // Stop all audio
        audio.stopAll();
      }

      // --- INITIALIZATION ---
      function init() {
        // Load high score
        loadHighScore();

        // Initialize lives display
        updateLivesDisplay();

        // Setup start button
        const startButton = document.getElementById("start-button");
        if (startButton) {
          // Initially disable button and show loading state
          startButton.disabled = true;
          startButton.classList.add("loading");
          startButton.textContent = "Loading Assets... 0%";
          startButton.addEventListener("click", async () => {
            if (!startButton.disabled) {
              await audio.unlock(); // Unlock audio on gesture
              startGame();
            }
          });
        }

        // Setup retry button
        const retryButton = document.getElementById("retry-button");
        if (retryButton) {
          retryButton.addEventListener("click", restartGame);
        }

        // Setup quit button
        const quitButton = document.getElementById("quit-button");
        if (quitButton) {
          quitButton.addEventListener("click", quitGame);
        }

        // Setup pause button
        const pauseButton = document.getElementById("pause-button");
        if (pauseButton) {
          pauseButton.addEventListener("click", togglePause);
        }

        // Load audio settings from cookies
        loadAudioSettings();

        // Setup settings menu
        setupSettingsMenu();
        // Load camera controls preference
        loadCameraControlsSetting();

        // Initialize audio (after user interaction)
        // Audio will be initialized on first user interaction
        // Load models
        loadTreeModel();
        loadRockModel();
        loadSignModel();
        loadFenceModel();
        loadGiftModel();

        scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.fogColor);

        // Mobile performance optimizations
        // 1. Detect device capability
        const isMobileDevice = isMobile();

        // Reduce draw distance on mobile (Desktop sees 300m, Mobile sees 110m)
        // This reduces the number of visible trees by ~60%
        const viewDistance = isMobileDevice ? 110 : 300;

        // Adjust fog so objects fade out smoothly before cutting off
        // Mobile fog starts at 30m and ends at 100m
        const fogStart = isMobileDevice ? 30 : 60;
        const fogEnd = isMobileDevice ? 100 : 120;
        scene.fog = new THREE.Fog(CONFIG.fogColor, fogStart, fogEnd);

        camera = new THREE.PerspectiveCamera(
          camParams.fov,
          window.innerWidth / window.innerHeight,
          0.1,
          viewDistance // Use reduced view distance on mobile
        );
        updateCamera();

        // 2. High-Performance / High-Quality Ratio
        // On iPhone 13 (DPR 3), this limits us to 2.0 (crisp).
        // On Desktop (DPR 1), it stays 1.0.
        // We avoid 3.0 because it provides diminishing returns for huge battery cost.
        const pixelRatio = Math.min(window.devicePixelRatio, 2.0);

        renderer = new THREE.WebGLRenderer({
          // 3. Keep AA ON.
          // The iPhone 13 Pro GPU is powerful enough to handle MSAA.
          antialias: true,
          alpha: false,
          powerPreference: "high-performance",
        });

        renderer.setPixelRatio(pixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        // 4. Keep Shadows OFF for mobile (This is the real performance saver)
        // High resolution + No Shadows = Crisp look, smooth framerate.
        renderer.shadowMap.enabled = !isMobileDevice;
        if (!isMobileDevice) {
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        }
        document.body.appendChild(renderer.domElement);

        // Lighting - match pose editor for consistent look
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(10, 20, 10);
        // Only cast shadows if not mobile
        dirLight.castShadow = !isMobileDevice;
        if (!isMobileDevice) {
          // Shadow map settings only needed on desktop
          dirLight.shadow.mapSize.width = 2048;
          dirLight.shadow.mapSize.height = 2048;
          dirLight.shadow.camera.near = 0.5;
          dirLight.shadow.camera.far = 200;
          dirLight.shadow.camera.left = -50;
          dirLight.shadow.camera.right = 50;
          dirLight.shadow.camera.top = 50;
          dirLight.shadow.camera.bottom = -50;
        }
        scene.add(dirLight);

        // Add a subtle fill light from the front for better model visibility
        const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.4);
        fillLight.position.set(-10, 10, -10);
        scene.add(fillLight);

        // Reduce geometry density on mobile for better performance
        const segments = isMobileDevice ? 32 : 64;
        const sphereGeo = new THREE.SphereGeometry(
          CONFIG.worldRadius,
          segments,
          segments
        );
        const sphereMat = new THREE.MeshLambertMaterial({
          color: CONFIG.groundColor,
        });
        worldSphere = new THREE.Mesh(sphereGeo, sphereMat);
        worldSphere.receiveShadow = !isMobile(); // Disable shadow receiving on mobile for performance
        scene.add(worldSphere);

        // Add instancers if they're already loaded
        if (treeInstances) worldSphere.add(treeInstances);
        if (rockInstances) worldSphere.add(rockInstances);
        if (redSignInstances) worldSphere.add(redSignInstances);
        if (blueSignInstances) worldSphere.add(blueSignInstances);
        if (fenceInstances) worldSphere.add(fenceInstances);

        // Spawn initial trees now that worldSphere is ready
        // (in case tree model loaded before worldSphere was created)
        if (treeModelTemplate) {
          spawnInitialTrees();
        }

        createPlayer();

        window.addEventListener("resize", onWindowResize, false);
        document.addEventListener("keydown", onKeyDown, false);
        setupSwipeControls();
        setupDebugControls();
        setupSkierControls();

        // Stop audio completely when window/tab is closed
        window.addEventListener("beforeunload", () => {
          audio.stopAll();
        });

        // Pause/resume audio when page visibility changes (for PWA and tab switching)
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            audio.stopAll();
          } else {
            // audio context may be suspended; only resume on gesture.
            // But we can at least try:
            audio.ensureMusic();
            audio.ensureAmbient({
              gameActive,
              isPaused,
              isGameOver,
              isJumping,
            });
          }
        });

        // Stop audio completely when page is being unloaded (for PWA)
        window.addEventListener("pagehide", () => {
          audio.stopAll();
        });

        // Initial trees will be spawned after the model loads (in loadTreeModel callback)
        // Don't spawn them here to avoid fallback procedural trees

        animate();
      }

      function setupDebugControls() {
        const header = document.getElementById("debug-header");
        const panel = document.getElementById("debug-panel");
        const icon = document.getElementById("toggle-icon");

        header.addEventListener("click", () => {
          panel.classList.toggle("collapsed");
          icon.innerText = panel.classList.contains("collapsed") ? "‚ñº" : "‚ñ≤";
        });

        document.getElementById("camY").value = camParams.y;
        document.getElementById("camZ").value = camParams.z;
        document.getElementById("lookY").value = camParams.lookY;
        document.getElementById("lookZ").value = camParams.lookZ;
        document.getElementById("camFov").value = camParams.fov;

        updateDebugDisplay();

        const inputs = ["camY", "camZ", "lookY", "lookZ", "camFov"];
        inputs.forEach((id) => {
          document.getElementById(id).addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            if (id === "camY") camParams.y = val;
            if (id === "camZ") camParams.z = val;
            if (id === "lookY") camParams.lookY = val;
            if (id === "lookZ") camParams.lookZ = val;
            if (id === "camFov") camParams.fov = val;
            updateCamera();
            updateDebugDisplay();
          });
        });
      }

      function updateCamera() {
        camera.position.set(0, camParams.y, camParams.z);
        camera.lookAt(0, camParams.lookY, camParams.lookZ);
        camera.fov = camParams.fov;
        camera.updateProjectionMatrix();
      }

      function updateDebugDisplay() {
        document.getElementById("valY").innerText = camParams.y;
        document.getElementById("valZ").innerText = camParams.z;
        document.getElementById("valLookY").innerText = camParams.lookY;
        document.getElementById("valLookZ").innerText = camParams.lookZ;
        document.getElementById("valFov").innerText = camParams.fov;

        const txt = `
camera.position.set(0, ${camParams.y}, ${camParams.z});<br>
camera.lookAt(0, ${camParams.lookY}, ${camParams.lookZ});<br>
fov: ${camParams.fov}
            `;
        document.getElementById("camera-readout").innerHTML = txt;
      }

      function setupSkierControls() {
        const header = document.getElementById("skier-header");
        const panel = document.getElementById("skier-panel");
        const icon = document.getElementById("skier-toggle-icon");

        header.addEventListener("click", () => {
          panel.classList.toggle("collapsed");
          icon.innerText = panel.classList.contains("collapsed") ? "‚ñº" : "‚ñ≤";
        });

        // Set initial values
        document.getElementById("skierScale").value = skierParams.scale;
        document.getElementById("skierX").value = skierParams.posX;
        document.getElementById("skierY").value = skierParams.posY;
        document.getElementById("skierZ").value = skierParams.posZ;
        document.getElementById("skierRotX").value = skierParams.rotX;
        document.getElementById("skierRotY").value = skierParams.rotY;
        document.getElementById("skierRotZ").value = skierParams.rotZ;

        updateSkierDisplay();

        // Setup event listeners
        document.getElementById("skierScale").addEventListener("input", (e) => {
          skierParams.scale = parseFloat(e.target.value);
          updateSkierTransform();
          updateSkierDisplay();
        });

        ["skierX", "skierY", "skierZ"].forEach((id) => {
          document.getElementById(id).addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            if (id === "skierX") skierParams.posX = val;
            if (id === "skierY") skierParams.posY = val;
            if (id === "skierZ") skierParams.posZ = val;
            updateSkierTransform();
            updateSkierDisplay();
          });
        });

        ["skierRotX", "skierRotY", "skierRotZ"].forEach((id) => {
          document.getElementById(id).addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            if (id === "skierRotX") skierParams.rotX = val;
            if (id === "skierRotY") skierParams.rotY = val;
            if (id === "skierRotZ") skierParams.rotZ = val;
            updateSkierTransform();
            updateSkierDisplay();
          });
        });
      }

      function updateSkierTransform() {
        if (skierModel) {
          skierModel.scale.set(
            skierParams.scale,
            skierParams.scale,
            skierParams.scale
          );
          skierModel.position.x = skierBaseOffset.x + skierParams.posX;
          skierModel.position.y = skierBaseOffset.y + skierParams.posY;
          skierModel.position.z = skierBaseOffset.z + skierParams.posZ;
          skierModel.rotation.x = skierParams.rotX;
          skierModel.rotation.y = skierParams.rotY;
          skierModel.rotation.z = skierParams.rotZ;
        }
      }

      function setupBoneControls(boneNames) {
        const boneControlsDiv = document.getElementById("bone-controls");
        const boneControlsContent = document.getElementById(
          "bone-controls-content"
        );

        // Show the bone controls section
        boneControlsDiv.style.display = "block";

        // Setup skiing pose button
        const skiingPoseBtn = document.getElementById("apply-skiing-pose");
        if (skiingPoseBtn) {
          skiingPoseBtn.addEventListener("click", applySkiingPose);
        }

        // Filter for common body parts (arms, legs, head, etc.)
        // Include bones with L_ or R_ prefix and main body bones
        const relevantBones = boneNames.filter((name) => {
          const lower = name.toLowerCase();
          // Include main bones (skip twist bones for cleaner UI)
          return (
            (lower.includes("arm") && !lower.includes("twist")) ||
            (lower.includes("hand") && !lower.includes("twist")) ||
            (lower.includes("thigh") && !lower.includes("twist")) ||
            (lower.includes("calf") && !lower.includes("twist")) ||
            (lower.includes("foot") && !lower.includes("twist")) ||
            lower.includes("head") ||
            lower.includes("neck") ||
            lower.includes("clavicle") ||
            lower.includes("spine") ||
            lower.includes("waist") ||
            lower.includes("pelvis") ||
            lower.includes("hip")
          );
        });

        // If no obvious body parts, show main bones (skip twist bones)
        const bonesToShow =
          relevantBones.length > 0
            ? relevantBones
            : boneNames
                .filter((n) => !n.toLowerCase().includes("twist"))
                .slice(0, 15);

        bonesToShow.forEach((boneName) => {
          // Initialize bone params
          if (!boneParams[boneName]) {
            boneParams[boneName] = { x: 0, y: 0, z: 0 };
          }

          // Create bone control group
          const boneGroup = document.createElement("div");
          boneGroup.style.marginBottom = "12px";
          boneGroup.style.paddingBottom = "8px";
          boneGroup.style.borderBottom = "1px solid #444";

          const boneTitle = document.createElement("div");
          boneTitle.style.fontSize = "0.8rem";
          boneTitle.style.color = "#f1c40f";
          boneTitle.style.marginBottom = "5px";
          boneTitle.style.fontWeight = "bold";
          boneTitle.textContent = boneName;
          boneGroup.appendChild(boneTitle);

          // Create rotation controls for X, Y, Z
          ["X", "Y", "Z"].forEach((axis) => {
            const controlGroup = document.createElement("div");
            controlGroup.className = "control-group";
            controlGroup.style.marginBottom = "4px";

            const label = document.createElement("label");
            label.textContent = `Rot ${axis}`;
            label.style.width = "60px";
            controlGroup.appendChild(label);

            const input = document.createElement("input");
            input.type = "range";
            input.id = `bone_${boneName}_${axis}`;
            input.min = "-1.57";
            input.max = "1.57";
            input.step = "0.05";
            input.value = boneParams[boneName][axis.toLowerCase()];
            input.style.width = "140px";
            controlGroup.appendChild(input);

            const span = document.createElement("span");
            span.id = `val_bone_${boneName}_${axis}`;
            span.textContent = "0.00";
            span.style.width = "40px";
            span.style.textAlign = "right";
            span.style.fontSize = "0.8rem";
            span.style.color = "#ccc";
            controlGroup.appendChild(span);

            boneGroup.appendChild(controlGroup);

            // Add event listener
            input.addEventListener("input", (e) => {
              const val = parseFloat(e.target.value);
              boneParams[boneName][axis.toLowerCase()] = val;
              updateBoneRotation(boneName);
              span.textContent = val.toFixed(2);
            });
          });

          boneControlsContent.appendChild(boneGroup);
        });
      }

      function applySkiingPose() {
        // Natural skiing pose - arms forward holding poles, legs bent, body leaning forward
        const skiingPose = {
          Root: { x: -1.57, y: 0.0, z: 1.57 },
          Hip: { x: 0.73, y: -0.83, z: -0.14 },
          Pelvis: { x: -2.2, y: -0.65, z: -2.44 },
          L_Thigh: { x: -3.06, y: 0.01, z: 0.6 },
          L_Calf: { x: 0.01, y: -0.01, z: -0.96 },
          L_Foot: { x: 1.02, y: 0.42, z: 1.5 },
          L_CalfTwist01: { x: -0.0, y: 0.0, z: -0.0 },
          L_CalfTwist02: { x: -0.0, y: 0.0, z: 0.0 },
          L_ThighTwist01: { x: 0.0, y: 0.0, z: -0.0 },
          L_ThighTwist02: { x: 0.0, y: -0.0, z: 0.0 },
          R_Thigh: { x: -2.88, y: 0.03, z: 0.6 },
          R_ThighTwist01: { x: 0.0, y: -0.0, z: -0.0 },
          R_ThighTwist02: { x: -0.0, y: -0.0, z: 0.0 },
          R_Calf: { x: -0.22, y: 0.11, z: -0.8 },
          R_Foot: { x: 1.12, y: 0.31, z: 1.4 },
          R_CalfTwist01: { x: 0.0, y: -0.0, z: 0.0 },
          R_CalfTwist02: { x: -0.0, y: -0.0, z: 0.0 },
          Waist: { x: -2.2, y: -0.65, z: -2.44 },
          Spine01: { x: -0.0, y: -0.0, z: -0.0 },
          Spine02: { x: 0.0, y: 0.0, z: 0.0 },
          NeckTwist01: { x: 0.0, y: -0.0, z: -0.0 },
          NeckTwist02: { x: 0.0, y: 0.0, z: 0.0 },
          Head: { x: -0.0, y: -0.47, z: -0.0 },
          L_Clavicle: { x: -2.37, y: -1.39, z: 2.39 },
          L_Upperarm: { x: 0.36, y: -0.0, z: -1.03 },
          L_Forearm: { x: 1.22, y: 0.99, z: -0.27 },
          L_ForearmTwist01: { x: -0.0, y: -0.0, z: -0.0 },
          L_ForearmTwist02: { x: 0.0, y: -0.0, z: 0.0 },
          L_Hand: { x: -0.0, y: -0.0, z: 0.0 },
          L_UpperarmTwist01: { x: 0.0, y: 0.0, z: -0.0 },
          L_UpperarmTwist02: { x: 0.0, y: 0.0, z: 0.0 },
          R_Clavicle: { x: -2.24, y: -1.41, z: -0.84 },
          R_Upperarm: { x: -0.32, y: 0.13, z: 0.88 },
          R_UpperarmTwist01: { x: -0.0, y: -0.0, z: -0.0 },
          R_UpperarmTwist02: { x: -0.0, y: -0.0, z: 0.0 },
          R_Forearm: { x: 1.38, y: -0.02, z: 0.48 },
          R_ForearmTwist01: { x: 0.0, y: -0.0, z: 0.0 },
          R_ForearmTwist02: { x: -0.0, y: 0.0, z: -0.0 },
          R_Hand: { x: 0.03, y: 0.38, z: 0.08 },
        };

        // Apply the pose
        Object.keys(skiingPose).forEach((boneName) => {
          if (skierBones[boneName] && skiingPose[boneName]) {
            const pose = skiingPose[boneName];
            boneParams[boneName] = {
              x: pose.x || 0,
              y: pose.y || 0,
              z: pose.z || 0,
            };

            // Store base values for animated bones
            if (boneName === "Pelvis") {
              animationParams.pelvis.baseY = boneParams[boneName].y;
            } else if (boneName === "Waist") {
              animationParams.waist.baseY = boneParams[boneName].y;
            } else if (boneName === "Head") {
              animationParams.head.baseY = boneParams[boneName].y;
            } else if (boneName === "L_Upperarm") {
              lUpperarmBaseZ = boneParams[boneName].z;
            } else if (boneName === "R_Upperarm") {
              rUpperarmBaseZ = boneParams[boneName].z;
            } else if (boneName === "L_Thigh") {
              lThighBaseY = boneParams[boneName].y;
            } else if (boneName === "R_Thigh") {
              rThighBaseY = boneParams[boneName].y;
            }

            // Update the bone rotation
            updateBoneRotation(boneName);

            // Update UI sliders if they exist
            ["X", "Y", "Z"].forEach((axis) => {
              const inputId = `bone_${boneName}_${axis}`;
              const spanId = `val_bone_${boneName}_${axis}`;
              const input = document.getElementById(inputId);
              const span = document.getElementById(spanId);

              if (input && span) {
                const val = boneParams[boneName][axis.toLowerCase()];
                input.value = val;
                span.textContent = val.toFixed(2);
              }
            });
          }
        });

        console.log("Skiing pose applied!");
      }

      // Helper function to set bone value only if it changed (optimization)
      function setBoneZ(boneName, z) {
        if (!boneParams[boneName]) return false;
        if (boneParams[boneName].z === z) return false; // skip work if unchanged
        boneParams[boneName].z = z;
        updateBoneRotation(boneName);
        return true;
      }

      function setBoneY(boneName, y) {
        if (!boneParams[boneName]) return false;
        if (boneParams[boneName].y === y) return false; // skip work if unchanged
        boneParams[boneName].y = y;
        updateBoneRotation(boneName);
        return true;
      }

      function updateBoneRotation(boneName) {
        if (skierBones[boneName] && boneParams[boneName]) {
          const bone = skierBones[boneName];
          const params = boneParams[boneName];

          // Use reusable Euler object instead of creating new one every frame
          _tempEuler.set(params.x, params.y, params.z);

          // Apply rotation (using quaternion for better bone manipulation)
          bone.quaternion.setFromEuler(_tempEuler);

          // Mark bones as dirty - skeleton will be updated once per frame
          bonesDirty = true;

          // REMOVED: skeleton.update() - Three.js handles this during rendering
          // We'll update once per frame if needed in animate()
        }
      }

      function updateSkierDisplay() {
        document.getElementById("valSkierScale").innerText =
          skierParams.scale.toFixed(1);
        document.getElementById("valSkierX").innerText =
          skierParams.posX.toFixed(2);
        document.getElementById("valSkierY").innerText =
          skierParams.posY.toFixed(2);
        document.getElementById("valSkierZ").innerText =
          skierParams.posZ.toFixed(2);
        document.getElementById("valSkierRotX").innerText =
          skierParams.rotX.toFixed(2);
        document.getElementById("valSkierRotY").innerText =
          skierParams.rotY.toFixed(2);
        document.getElementById("valSkierRotZ").innerText =
          skierParams.rotZ.toFixed(2);

        const txt = `
skierModel.scale.set(${skierParams.scale.toFixed(
          1
        )}, ${skierParams.scale.toFixed(1)}, ${skierParams.scale.toFixed(
          1
        )});<br>
skierModel.position.set(${skierParams.posX.toFixed(
          2
        )}, ${skierParams.posY.toFixed(2)}, ${skierParams.posZ.toFixed(2)});<br>
skierModel.rotation.set(${skierParams.rotX.toFixed(
          2
        )}, ${skierParams.rotY.toFixed(2)}, ${skierParams.rotZ.toFixed(2)});
        `;
        document.getElementById("skier-readout").innerHTML = txt;
      }

      function createPlayer() {
        playerGroup = new THREE.Group();
        playerGroup.position.set(0, CONFIG.worldRadius, 0);
        scene.add(playerGroup);
        player = playerGroup;

        // Load the GLB model
        const loader = createGLTFLoader();
        loader.load(
          "/assets/models/skier_v1.glb",
          (gltf) => {
            skierModel = gltf.scene;
            // Don't optimize skier model - it's just one object and optimization may interfere with animations

            // Center the model and position it on the ground (base positioning)
            const box = new THREE.Box3().setFromObject(skierModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Center horizontally but keep feet on ground (base offset)
            skierBaseOffset.x = -center.x;
            skierBaseOffset.y = -box.min.y;
            skierBaseOffset.z = -center.z;

            // Apply user-controlled transforms
            skierModel.scale.set(
              skierParams.scale,
              skierParams.scale,
              skierParams.scale
            );
            skierModel.position.x = skierBaseOffset.x + skierParams.posX;
            skierModel.position.y = skierBaseOffset.y + skierParams.posY;
            skierModel.position.z = skierBaseOffset.z + skierParams.posZ;
            skierModel.rotation.x = skierParams.rotX;
            skierModel.rotation.y = skierParams.rotY;
            skierModel.rotation.z = skierParams.rotZ;

            // Enable shadows and brighten materials (disable on mobile for performance)
            const enableShadows = !isMobile();
            skierModel.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = enableShadows;
                child.receiveShadow = enableShadows;

                // Fix dark materials - make them brighter and more responsive to light
                if (child.material) {
                  // If it's a PBR material, adjust it
                  if (child.material.metalness !== undefined) {
                    child.material.metalness = Math.min(
                      child.material.metalness,
                      0.1
                    );
                    child.material.roughness = Math.max(
                      child.material.roughness,
                      0.8
                    );
                  }

                  // Brighten the material
                  if (child.material.color) {
                    child.material.color.multiplyScalar(1.5);
                  }

                  // Add emissive for slight self-illumination
                  if (child.material.emissive) {
                    child.material.emissive.setRGB(0.1, 0.1, 0.1);
                    child.material.emissiveIntensity = 0.3;
                  }

                  child.material.needsUpdate = true;
                }
              }

              // Store bones for manipulation
              if (child.isBone || child.type === "Bone") {
                skierBones[child.name] = child;
                console.log("Found bone:", child.name);
              }
            });

            // Also check for skeleton in the scene
            if (gltf.scene.children[0] && gltf.scene.children[0].skeleton) {
              const skeleton = gltf.scene.children[0].skeleton;
              skeleton.bones.forEach((bone) => {
                skierBones[bone.name] = bone;
                console.log("Found skeleton bone:", bone.name);
              });
            }

            // Log all found bones
            const boneNames = Object.keys(skierBones);
            console.log("Total bones found:", boneNames.length);
            console.log("Bone names:", boneNames);

            // Setup bone controls if bones exist
            if (boneNames.length > 0) {
              // Initialize bone rotations from current bone states
              boneNames.forEach((boneName) => {
                const bone = skierBones[boneName];
                if (bone) {
                  const euler = new THREE.Euler().setFromQuaternion(
                    bone.quaternion
                  );
                  boneParams[boneName] = {
                    x: euler.x,
                    y: euler.y,
                    z: euler.z,
                  };
                }
              });
              setupBoneControls(boneNames);

              // Apply skiing pose automatically on load
              applySkiingPose();
            } else {
              console.log("No bones found - model may not be rigged");
            }

            playerGroup.add(skierModel);

            // Setup animations if present
            if (gltf.animations && gltf.animations.length > 0) {
              mixer = new THREE.AnimationMixer(skierModel);

              // Log available animations
              console.log(
                "Available animations:",
                gltf.animations.map((a) => a.name)
              );

              // Play the first animation by default (usually idle or ski)
              const action = mixer.clipAction(gltf.animations[0]);
              action.play();
            }

            console.log("Skier model loaded! Size:", size);
            updateSkierDisplay();
            assetLoadingState.skier = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          },
          (progress) => {
            console.log(
              "Loading skier:",
              ((progress.loaded / progress.total) * 100).toFixed(1) + "%"
            );
            updateLoadingProgress();
          },
          (error) => {
            console.error("Error loading skier model:", error);
            // Fallback to procedural skier if model fails to load
            createFallbackPlayer();
            assetLoadingState.skier = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          }
        );
      }

      // Fallback procedural player in case GLB fails to load
      function createFallbackPlayer() {
        const skinMat = new THREE.MeshLambertMaterial({ color: 0xffccaa });
        const suitMat = new THREE.MeshLambertMaterial({ color: 0xe67e22 });
        const skiMat = new THREE.MeshLambertMaterial({ color: 0x333333 });

        const enableShadows = !isMobile();
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.3, 1.5, 8),
          suitMat
        );
        body.position.y = 0.75;
        body.castShadow = enableShadows;
        playerGroup.add(body);

        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 16, 16),
          skinMat
        );
        head.position.y = 1.7;
        head.castShadow = enableShadows;
        playerGroup.add(head);

        const skiGeo = new THREE.BoxGeometry(0.3, 0.1, 2.5);
        const skiL = new THREE.Mesh(skiGeo, skiMat);
        skiL.position.set(-0.4, 0.05, 0);
        skiL.castShadow = enableShadows;
        playerGroup.add(skiL);

        const skiR = new THREE.Mesh(skiGeo, skiMat);
        skiR.position.set(0.4, 0.05, 0);
        skiR.castShadow = enableShadows;
        playerGroup.add(skiR);
      }

      function placeOnSphere(obj, angleRad, xOffset) {
        if (!worldSphere) {
          console.warn("worldSphere not initialized yet, skipping placement");
          return;
        }
        const R = CONFIG.worldRadius;
        const y = R * Math.cos(angleRad);
        const z = R * Math.sin(angleRad);

        obj.position.set(xOffset, y, z);
        obj.rotation.x = angleRad;

        worldSphere.add(obj);
      }

      // --- ASSETS ---
      let treeModelTemplate = null;
      let rockModelTemplate = null;
      let redSignModelTemplate = null;
      let blueSignModelTemplate = null;
      let fenceModelTemplate = null;
      let giftModelTemplate = null;

      // Setup DRACO loader for compressed geometry
      const dracoLoader = new THREE.DRACOLoader();
      dracoLoader.setDecoderPath(
        "https://www.gstatic.com/draco/versioned/decoders/1.5.6/"
      );
      dracoLoader.setDecoderConfig({ type: "js" });

      // Helper function to create GLTFLoader with DRACO support
      function createGLTFLoader() {
        const loader = new THREE.GLTFLoader();
        loader.setDRACOLoader(dracoLoader);
        return loader;
      }

      function loadTreeModel() {
        const loader = createGLTFLoader();
        loader.load(
          "assets/models/alpine_tree_v1.glb",
          (gltf) => {
            treeModelTemplate = gltf.scene;
            optimizeModelForMobile(treeModelTemplate); // Optimize for mobile

            // Create instanced mesh
            const MAX_TREES = isMobile() ? 200 : 600;
            treeInstances = createInstancerFromGLB(
              treeModelTemplate,
              MAX_TREES
            );
            const enableShadows = !isMobile();
            treeInstances.castShadow = enableShadows;
            treeInstances.receiveShadow = enableShadows;
            if (worldSphere) {
              worldSphere.add(treeInstances);
            }

            console.log("Alpine tree model loaded successfully");
            // Spawn initial trees after model is loaded (only if worldSphere is ready)
            if (worldSphere) {
              spawnInitialTrees();
            }
            assetLoadingState.tree = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          },
          (xhr) => {
            console.log(
              `Loading tree: ${((xhr.loaded / xhr.total) * 100).toFixed(1)}%`
            );
            updateLoadingProgress();
          },
          (error) => {
            console.error("Error loading alpine tree model:", error);
            // Still spawn trees even if loading fails (will use fallback)
            spawnInitialTrees();
            assetLoadingState.tree = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          }
        );
      }

      function loadRockModel() {
        const loader = createGLTFLoader();
        loader.load(
          "assets/models/rock_v1.glb",
          (gltf) => {
            rockModelTemplate = gltf.scene;
            optimizeModelForMobile(rockModelTemplate); // Optimize for mobile

            // Create instanced mesh
            const MAX_ROCKS = isMobile() ? 100 : 300;
            rockInstances = createInstancerFromGLB(
              rockModelTemplate,
              MAX_ROCKS
            );
            const enableShadows = !isMobile();
            rockInstances.castShadow = enableShadows;
            rockInstances.receiveShadow = enableShadows;
            if (worldSphere) {
              worldSphere.add(rockInstances);
            }

            console.log("Rock model loaded successfully");
            assetLoadingState.rock = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          },
          (xhr) => {
            console.log(
              `Loading rock: ${((xhr.loaded / xhr.total) * 100).toFixed(1)}%`
            );
            updateLoadingProgress();
          },
          (error) => {
            console.error("Error loading rock model:", error);
            assetLoadingState.rock = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          }
        );
      }

      function loadSignModel() {
        const loader = createGLTFLoader();

        // Load red sign
        loader.load(
          "assets/models/red_sign_v1.glb",
          (gltf) => {
            redSignModelTemplate = gltf.scene;
            optimizeModelForMobile(redSignModelTemplate); // Optimize for mobile

            // Create instanced mesh
            const MAX_SIGNS = isMobile() ? 50 : 150;
            redSignInstances = createInstancerFromGLB(
              redSignModelTemplate,
              MAX_SIGNS
            );
            const enableShadows = !isMobile();
            redSignInstances.castShadow = enableShadows;
            redSignInstances.receiveShadow = enableShadows;
            if (worldSphere) {
              worldSphere.add(redSignInstances);
            }

            console.log("Red sign model loaded successfully");
            assetLoadingState.redSign = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();

            // When red sign loads, check if all boundary instancers are ready
            // If so, spawn initial boundaries immediately
            if (
              worldSphere &&
              fenceInstances &&
              redSignInstances &&
              blueSignInstances
            ) {
              spawnInitialBoundariesIfNeeded();
            }
          },
          (xhr) => {
            console.log(
              `Loading red sign: ${((xhr.loaded / xhr.total) * 100).toFixed(
                1
              )}%`
            );
            updateLoadingProgress();
          },
          (error) => {
            console.error("Error loading red sign model:", error);
            assetLoadingState.redSign = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          }
        );

        // Load blue sign
        loader.load(
          "assets/models/blue_sign_v1.glb",
          (gltf) => {
            blueSignModelTemplate = gltf.scene;
            optimizeModelForMobile(blueSignModelTemplate); // Optimize for mobile

            // Create instanced mesh
            const MAX_SIGNS = isMobile() ? 50 : 150;
            blueSignInstances = createInstancerFromGLB(
              blueSignModelTemplate,
              MAX_SIGNS
            );
            const enableShadows = !isMobile();
            blueSignInstances.castShadow = enableShadows;
            blueSignInstances.receiveShadow = enableShadows;
            if (worldSphere) {
              worldSphere.add(blueSignInstances);
            }

            console.log("Blue sign model loaded successfully");
            assetLoadingState.blueSign = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();

            // When blue sign loads, check if all boundary instancers are ready
            // If so, spawn initial boundaries immediately
            if (
              worldSphere &&
              fenceInstances &&
              redSignInstances &&
              blueSignInstances
            ) {
              spawnInitialBoundariesIfNeeded();
            }
          },
          (xhr) => {
            console.log(
              `Loading blue sign: ${((xhr.loaded / xhr.total) * 100).toFixed(
                1
              )}%`
            );
            updateLoadingProgress();
          },
          (error) => {
            console.error("Error loading blue sign model:", error);
            assetLoadingState.blueSign = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          }
        );
      }

      function loadFenceModel() {
        const loader = createGLTFLoader();
        loader.load(
          "assets/models/wooden_fence_v1.glb",
          (gltf) => {
            fenceModelTemplate = gltf.scene;
            optimizeModelForMobile(fenceModelTemplate); // Optimize for mobile

            // Create instanced mesh
            const MAX_FENCES = isMobile() ? 50 : 150;
            fenceInstances = createInstancerFromGLB(
              fenceModelTemplate,
              MAX_FENCES
            );
            const enableShadows = !isMobile();
            fenceInstances.castShadow = enableShadows;
            fenceInstances.receiveShadow = enableShadows;
            if (worldSphere) {
              worldSphere.add(fenceInstances);
            }

            console.log("Wooden fence model loaded successfully");
            assetLoadingState.fence = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();

            // When fence loads, check if all boundary instancers are ready
            // If so, spawn initial boundaries immediately
            if (
              worldSphere &&
              fenceInstances &&
              redSignInstances &&
              blueSignInstances
            ) {
              spawnInitialBoundariesIfNeeded();
            }
          },
          (xhr) => {
            console.log(
              `Loading fence: ${((xhr.loaded / xhr.total) * 100).toFixed(1)}%`
            );
            updateLoadingProgress();
          },
          (error) => {
            console.error("Error loading fence model:", error);
            assetLoadingState.fence = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          }
        );
      }

      function loadGiftModel() {
        const loader = createGLTFLoader();
        loader.load(
          "assets/models/gift_v1.glb",
          (gltf) => {
            giftModelTemplate = gltf.scene;
            optimizeModelForMobile(giftModelTemplate); // Optimize for mobile
            console.log("Gift model loaded successfully");
            assetLoadingState.gift = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          },
          (xhr) => {
            console.log(
              `Loading gift: ${((xhr.loaded / xhr.total) * 100).toFixed(1)}%`
            );
            updateLoadingProgress();
          },
          (error) => {
            console.error("Error loading gift model:", error);
            assetLoadingState.gift = true;
            updateLoadingProgress();
            checkAllAssetsLoaded();
          }
        );
      }

      function spawnInitialTrees() {
        // Only spawn if worldSphere is initialized
        if (!worldSphere) {
          console.warn(
            "worldSphere not initialized yet, deferring initial tree spawn"
          );
          return;
        }

        // Initial Objects
        // Spawn ahead of player so they are visible immediately
        for (let i = 0; i < 30; i++) {
          // Spawn angle: 0.5 down to -1.0 (covering visible range)
          let angle = 0.5 - i * 0.05;
          spawnTree(angle, true);
          // Try to spawn boundaries - if instancers aren't ready, they'll be spawned later
          spawnBoundary(angle);
        }
      }

      // Spawn initial boundaries if they weren't ready when spawnInitialTrees() was called
      function spawnInitialBoundariesIfNeeded() {
        if (!worldSphere) return;

        const boundariesReady =
          fenceInstances && redSignInstances && blueSignInstances;
        if (!boundariesReady) return;

        // Check if boundaries already exist in the initial area (angles from -1.0 to 0.5)
        // Use a more lenient check - if we have fewer than 30 boundaries in range, spawn them
        const boundariesInRange = activeBoundaries.filter(
          (b) => b.angle >= -1.0 && b.angle <= 0.5
        );

        // If we don't have enough boundaries in the initial area, spawn them
        // This handles the case where some boundaries were spawned but not all
        if (boundariesInRange.length < 30) {
          // Reset boundaryAlternator to start fresh pattern (important!)
          // This ensures boundaries spawn with the correct fence/sign pattern
          boundaryAlternator = 0;

          for (let i = 0; i < 30; i++) {
            const angle = 0.5 - i * 0.05;
            // Only spawn if boundary doesn't already exist at this angle
            const exists = activeBoundaries.some(
              (b) => Math.abs(b.angle - angle) < 0.01
            );
            if (!exists) {
              spawnBoundary(angle);
            }
          }

          // Update instance matrices after batch spawn - CRITICAL for visibility
          // This ensures boundaries are visible immediately
          if (fenceInstances) fenceInstances.instanceMatrix.needsUpdate = true;
          if (redSignInstances)
            redSignInstances.instanceMatrix.needsUpdate = true;
          if (blueSignInstances)
            blueSignInstances.instanceMatrix.needsUpdate = true;
        }
      }

      function createTree(isDecoration = false, reuseFromPool = true) {
        if (!treeModelTemplate) {
          // Model not loaded yet - return null to skip spawning
          console.warn("Tree model not loaded yet, skipping tree creation");
          return null;
        }

        // Try to reuse from pool first (object pooling optimization)
        let tree = null;
        if (reuseFromPool && treePool.length > 0) {
          tree = treePool.pop();
          tree.visible = true; // Make it visible again
        } else {
          // Clone the GLB model only if pool is empty
          tree = treeModelTemplate.clone();
        }

        // Enable shadows on all meshes (disable on mobile for performance)
        const enableShadows = !isMobile();
        tree.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = enableShadows;
            child.receiveShadow = enableShadows;
          }
        });

        // Randomize scale - slight variation
        const baseScale = isDecoration ? 2.5 : 4.0;
        const scaleVariation = 0.8 + Math.random() * 0.5;
        const scale = baseScale * scaleVariation;
        tree.scale.set(scale, scale, scale);

        // Randomize Y rotation significantly for variety
        const randomYRotation = Math.random() * Math.PI * 2; // 0 to 360 degrees
        tree.rotation.y = randomYRotation;

        return tree;
      }

      function spawnTree(angle, isDecoration = false, laneIndex = 0) {
        if (!treeInstances) return;

        const id = allocTreeId();
        if (id >= treeInstances.count) return; // out of capacity

        let xPos;
        if (isDecoration) {
          const side = Math.random() > 0.5 ? 1 : -1;
          xPos = side * (10 + Math.random() * 15);
        } else {
          const lane = laneIndex - 1;
          xPos = lane * CONFIG.laneWidth;
        }

        const baseScale = isDecoration ? 2.5 : 4.0;
        const scaleVariation = 0.8 + Math.random() * 0.5;
        const scale = baseScale * scaleVariation;
        const yRot = Math.random() * Math.PI * 2;

        setOnSphereInstance(
          treeInstances,
          id,
          angle,
          xPos,
          scale,
          yRot,
          isDecoration,
          0,
          true // isTree = true
        );

        activeObstacles.push({
          kind: "tree",
          id,
          angle,
          lane: isDecoration ? null : laneIndex - 1,
        });
      }

      function createRock(reuseFromPool = true) {
        if (!rockModelTemplate) {
          // Model not loaded yet - return null to skip spawning
          console.warn("Rock model not loaded yet, skipping rock creation");
          return null;
        }

        // Try to reuse from pool first (object pooling optimization)
        let rock = null;
        if (reuseFromPool && rockPool.length > 0) {
          rock = rockPool.pop();
          rock.visible = true; // Make it visible again
        } else {
          // Clone the GLB model only if pool is empty
          rock = rockModelTemplate.clone();
        }

        // Enable shadows on all meshes (disable on mobile for performance)
        const enableShadows = !isMobile();
        rock.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = enableShadows;
            child.receiveShadow = enableShadows;
          }
        });

        // Randomize scale - small variation (rocks should be smaller than trees)
        const baseScale = 2.0; // Smaller than trees (trees are 5.0-8.0)
        const scaleVariation = 0.6 + Math.random() * 0.4; // 0.6 to 1.0 variation
        const scale = baseScale * scaleVariation;
        rock.scale.set(scale, scale, scale);

        // Randomize Y rotation significantly for variety (big variation)
        const randomYRotation = Math.random() * Math.PI * 2; // 0 to 360 degrees
        rock.rotation.y = randomYRotation;

        // Also randomize X and Z rotation for more natural look
        rock.rotation.x = (Math.random() - 0.5) * 0.3; // Small tilt
        rock.rotation.z = (Math.random() - 0.5) * 0.3; // Small tilt

        return rock;
      }

      function spawnBarrier(angle, laneIndex) {
        if (!rockInstances) return;

        const id = allocRockId();
        if (id >= rockInstances.count) return; // out of capacity

        const lane = laneIndex - 1;
        const xPos = lane * CONFIG.laneWidth;

        const baseScale = 2.0;
        const scaleVariation = 0.6 + Math.random() * 0.4;
        const scale = baseScale * scaleVariation;
        const yRot = Math.random() * Math.PI * 2;

        setOnSphereInstance(rockInstances, id, angle, xPos, scale, yRot);

        activeBarriers.push({
          kind: "rock",
          id,
          angle,
          lane: laneIndex - 1,
          passed: false,
        });
      }

      // --- NEW: BOUNDARY DECORATIONS (Flags/Fences) ---
      const bFlagPoleGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8);
      const bFlagCanvasGeo = new THREE.PlaneGeometry(1.2, 0.8);
      const bFlagRedMat = new THREE.MeshLambertMaterial({
        color: 0xe74c3c,
        side: THREE.DoubleSide,
      });
      const bFlagBlueMat = new THREE.MeshLambertMaterial({
        color: 0x3498db,
        side: THREE.DoubleSide,
      });
      const bFenceGeo = new THREE.BoxGeometry(3, 1.5, 0.2);
      const bFenceMat = new THREE.MeshLambertMaterial({ color: 0x8d6e63 });

      function spawnBoundary(angle) {
        boundaryAlternator++;
        const isFence = boundaryAlternator % 4 === 0;

        if (isFence) {
          // Spawn fence on left
          if (fenceInstances) {
            const leftId = allocFenceId();
            if (leftId < fenceInstances.count) {
              const scale = 3.25;
              const yRot = 0;
              setOnSphereInstance(
                fenceInstances,
                leftId,
                angle,
                -9,
                scale,
                yRot
              );
              activeBoundaries.push({
                kind: "fence",
                id: leftId,
                instancer: fenceInstances,
                angle: angle,
                type: "fence",
              });
            }
          }

          // Spawn fence on right
          if (fenceInstances) {
            const rightId = allocFenceId();
            if (rightId < fenceInstances.count) {
              const scale = 3.25;
              const yRot = 0;
              setOnSphereInstance(
                fenceInstances,
                rightId,
                angle,
                9,
                scale,
                yRot
              );
              activeBoundaries.push({
                kind: "fence",
                id: rightId,
                instancer: fenceInstances,
                angle: angle,
                type: "fence",
              });
            }
          }
        } else {
          // Spawn sign on left (randomly choose red or blue)
          const useRedLeft = Math.random() > 0.5;
          const leftInstancer = useRedLeft
            ? redSignInstances
            : blueSignInstances;
          if (leftInstancer) {
            const leftId = useRedLeft ? allocRedSignId() : allocBlueSignId();
            if (leftId < leftInstancer.count) {
              const scale = 1.5;
              const yRot = (Math.random() - 0.5) * 0.4;
              setOnSphereInstance(
                leftInstancer,
                leftId,
                angle,
                -9,
                scale,
                yRot,
                false,
                0.5
              );
              activeBoundaries.push({
                kind: "sign",
                id: leftId,
                instancer: leftInstancer,
                angle: angle,
                type: "sign",
                signType: useRedLeft ? "red" : "blue",
              });
            }
          }

          // Spawn sign on right (randomly choose red or blue)
          const useRedRight = Math.random() > 0.5;
          const rightInstancer = useRedRight
            ? redSignInstances
            : blueSignInstances;
          if (rightInstancer) {
            const rightId = useRedRight ? allocRedSignId() : allocBlueSignId();
            if (rightId < rightInstancer.count) {
              const scale = 1.5;
              const yRot = (Math.random() - 0.5) * 0.4;
              setOnSphereInstance(
                rightInstancer,
                rightId,
                angle,
                9,
                scale,
                yRot,
                false,
                0.5
              );
              activeBoundaries.push({
                kind: "sign",
                id: rightId,
                instancer: rightInstancer,
                angle: angle,
                type: "sign",
                signType: useRedRight ? "red" : "blue",
              });
            }
          }
        }
      }

      function createSign() {
        // Randomly choose between red and blue sign
        const useRed = Math.random() > 0.5;
        const signTemplate = useRed
          ? redSignModelTemplate
          : blueSignModelTemplate;

        if (!signTemplate) {
          // Model not loaded yet - return null to skip spawning
          console.warn("Sign model not loaded yet, skipping sign creation");
          return null;
        }

        // Clone the GLB model
        const sign = signTemplate.clone();

        // Enable shadows on all meshes (disable on mobile for performance)
        const enableShadows = !isMobile();
        sign.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = enableShadows;
            child.receiveShadow = enableShadows;
          }
        });

        // Scale up the sign
        const scale = 1.5;
        sign.scale.set(scale, scale, scale);

        // Raise the sign so it's flush with the ground (not buried)
        // Adjust Y position based on scale to keep it at ground level
        sign.position.y += 0.5; // Adjust this value to position sign correctly

        // Randomize Y rotation a bit
        const randomYRotation = (Math.random() - 0.5) * 0.4; // -0.2 to 0.2 radians (~-11 to 11 degrees)
        sign.rotation.y = randomYRotation;

        return sign;
      }

      function createFence() {
        if (!fenceModelTemplate) {
          // Model not loaded yet - return null to skip spawning
          console.warn("Fence model not loaded yet, skipping fence creation");
          return null;
        }

        // Clone the GLB model
        const fence = fenceModelTemplate.clone();

        // Enable shadows on all meshes (disable on mobile for performance)
        const enableShadows = !isMobile();
        fence.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = enableShadows;
            child.receiveShadow = enableShadows;
          }
        });

        // Scale up the fence
        const scale = 3.25;
        fence.scale.set(scale, scale, scale);

        return fence;
      }

      function createBoundaryObject(isFence, isLeft) {
        const group = new THREE.Group();

        if (isFence) {
          // Use wooden fence model instead of procedural fence
          const fence = createFence();
          if (fence) {
            // Adjust fence Y position (can be modified here)
            fence.position.y = 0.5; // Adjust this value to raise/lower the fence
            group.add(fence);
          } else {
            // Fallback to procedural fence if model not loaded
            const proceduralFence = new THREE.Mesh(bFenceGeo, bFenceMat);
            proceduralFence.position.y = 0.75;
            proceduralFence.rotation.y = Math.PI / 2;
            proceduralFence.castShadow = true;
            group.add(proceduralFence);
          }
        } else {
          // Use red sign model instead of flags
          const sign = createSign();
          if (sign) {
            group.add(sign);
          } else {
            // Fallback to flag if model not loaded
            const pole = new THREE.Mesh(
              bFlagPoleGeo,
              new THREE.MeshLambertMaterial({ color: 0x777777 })
            );
            pole.position.y = 1.25;
            pole.castShadow = true;
            group.add(pole);

            const flag = new THREE.Mesh(bFlagCanvasGeo, bFlagRedMat);
            flag.position.y = 1.8;
            flag.position.x = isLeft ? 0.6 : -0.6;
            group.add(flag);
          }
        }
        return group;
      }

      // --- SPAWN LOGIC ---
      function spawnRow(angle) {
        const rand = Math.random();
        const lanes = [0, 1, 2];
        lanes.sort(() => Math.random() - 0.5);

        // Ensure at least one lane is always clear (max 2 obstacles per row)
        if (rand < 0.4) {
          // 40% chance: 1 tree
          spawnTree(angle, false, lanes[0]);
        } else if (rand < 0.65) {
          // 25% chance: 2 trees (leaves 1 lane clear)
          spawnTree(angle, false, lanes[0]);
          spawnTree(angle, false, lanes[1]);
        } else if (rand < 0.8) {
          // 15% chance: 1 barrier
          spawnBarrier(angle, lanes[0]);
        } else {
          // 20% chance: 1 tree + 1 barrier (in different lanes, leaves 1 lane clear)
          spawnTree(angle, false, lanes[0]);
          spawnBarrier(angle, lanes[1]);
        }
        // Spawn decoration tree further out (not in lanes)
        // Reduce spawn rate by 15% on mobile (85% chance) - less reduction for better visuals
        const shouldSpawnDecorationTree = isMobile()
          ? Math.random() < 0.85
          : true;
        if (shouldSpawnDecorationTree) {
          spawnTree(angle, true);
        }

        // Update instance matrices after batch spawn
        if (treeInstances) treeInstances.instanceMatrix.needsUpdate = true;
        if (rockInstances) rockInstances.instanceMatrix.needsUpdate = true;
      }

      function createGift() {
        if (!giftModelTemplate) {
          console.warn("Gift model not loaded yet, skipping gift creation");
          return null;
        }

        // Clone the GLB model
        const gift = giftModelTemplate.clone();

        // Enable shadows on all meshes (disable on mobile for performance)
        const enableShadows = !isMobile();
        gift.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = enableShadows;
            child.receiveShadow = enableShadows;
          }
        });

        // Set scale for gift
        const scale = 1.25;
        gift.scale.set(scale, scale, scale);

        return gift;
      }

      function spawnGift(angle) {
        // Don't spawn if gift already collected or already exists
        if (giftCollected || activeGift) return;

        const gift = createGift();
        if (!gift) return;

        // Find a free lane (lane with no obstacles)
        const occupiedLanes = new Set();

        // Check obstacles at this angle
        activeObstacles.forEach((obj) => {
          // Check if obstacle is near this angle
          const angleDiff = Math.abs(obj.angle - angle);
          if (angleDiff < 0.1 && obj.lane !== null && obj.lane !== undefined) {
            // Use stored lane instead of getWorldPosition
            const lane = Math.round(obj.lane);
            if (lane >= -1 && lane <= 1) {
              occupiedLanes.add(lane);
            }
          }
        });

        // Check barriers at this angle
        activeBarriers.forEach((obj) => {
          const angleDiff = Math.abs(obj.angle - angle);
          if (angleDiff < 0.1 && obj.lane !== null && obj.lane !== undefined) {
            // Use stored lane instead of getWorldPosition
            const lane = Math.round(obj.lane);
            if (lane >= -1 && lane <= 1) {
              occupiedLanes.add(lane);
            }
          }
        });

        // Find a free lane
        const freeLanes = [-1, 0, 1].filter((lane) => !occupiedLanes.has(lane));
        if (freeLanes.length === 0) {
          // No free lanes, don't spawn gift
          return;
        }

        // Pick a random free lane
        const selectedLane =
          freeLanes[Math.floor(Math.random() * freeLanes.length)];
        const xPos = selectedLane * CONFIG.laneWidth;

        placeOnSphere(gift, angle, xPos);

        // Position gift slightly above ground for floating effect
        // Use the same sphere surface normal system as trees/rocks
        const R = CONFIG.worldRadius;
        const normalY = Math.cos(angle);
        const normalZ = Math.sin(angle);
        // Move along the normal by the offset amount (using same offset as trees)
        gift.position.y += CONFIG.giftVerticalOffset * normalY;
        gift.position.z += CONFIG.giftVerticalOffset * normalZ;

        // Store gift with floating animation data
        activeGift = {
          mesh: gift,
          angle: angle,
          floatOffset: 0,
          floatSpeed: 1.5 + Math.random() * 0.5, // Random float speed
          baseY: gift.position.y,
        };
      }

      function updateGiftAnimation(deltaTime) {
        if (!activeGift || !gameActive || isPaused) return;

        // Update floating animation
        activeGift.floatOffset += deltaTime * activeGift.floatSpeed;
        const floatAmount = Math.sin(activeGift.floatOffset) * 0.5; // Float up and down
        activeGift.mesh.position.y = activeGift.baseY + floatAmount;

        // Rotate gift slowly
        activeGift.mesh.rotation.y += deltaTime * 0.5;
      }

      function updateSubtleAnimations(deltaTime) {
        animationTime += deltaTime * animationSpeed;

        // Pelvis - slower, smoother sway (only if not turning)
        if (
          boneParams.Pelvis &&
          skierBones.Pelvis &&
          !isRightTurning &&
          !isLeftTurning
        ) {
          const offset =
            Math.sin(animationTime * 0.8) * animationParams.pelvis.amplitude;
          boneParams.Pelvis.y = animationParams.pelvis.baseY + offset;
          updateBoneRotation("Pelvis");
        }

        // Waist - slightly faster, counter to pelvis
        if (boneParams.Waist && skierBones.Waist) {
          const offset =
            Math.sin(animationTime * 1.2 + Math.PI * 0.3) *
            animationParams.waist.amplitude;
          boneParams.Waist.y = animationParams.waist.baseY + offset;
          updateBoneRotation("Waist");
        }

        // Head - faster, subtle movement (only if not turning)
        if (
          boneParams.Head &&
          skierBones.Head &&
          !isRightTurning &&
          !isLeftTurning
        ) {
          const offset =
            Math.sin(animationTime * 1.5 + Math.PI * 0.5) *
            animationParams.head.amplitude;
          boneParams.Head.y = animationParams.head.baseY + offset;
          updateBoneRotation("Head");
        }
      }

      // Frame rate limiting for mobile
      let lastFrameTime = 0;
      const targetFPS = isMobile() ? 30 : 60; // 30 FPS on mobile, 60 on desktop
      const frameInterval = 1000 / targetFPS;

      function animate(currentTime) {
        requestAnimationFrame(animate);

        // Frame rate limiting for mobile
        const elapsed = currentTime - lastFrameTime;
        if (elapsed < frameInterval) {
          return; // Skip frame to maintain target FPS
        }
        lastFrameTime = currentTime - (elapsed % frameInterval);

        // Update animation mixer (only if not paused)
        const delta = clock.getDelta();
        if (!isPaused && mixer) {
          mixer.update(delta);
        }

        // Update subtle bone animations (only if not paused)
        // Reduce animation update frequency on mobile (every other frame)
        if (!isPaused) {
          const isMobileDevice = isMobile();
          if (!isMobileDevice || animationFrameCounter % 2 === 0) {
            updateSubtleAnimations(delta);
          }
          if (isMobileDevice) animationFrameCounter++;
        }

        // Update jump animation (only if not paused)
        if (!isPaused) {
          updateJumpAnimation(delta);
        }

        // Update crash animation (only if not paused)
        if (!isPaused) {
          updateCrashAnimation(delta);
        }

        // Update turn animations (only if not paused)
        if (!isPaused) {
          updateRightTurnAnimation(delta);
          updateLeftTurnAnimation(delta);
          updateGiftAnimation(delta);
        }

        // World rotation (only if not paused)
        if (!isPaused) {
          worldSphere.rotation.x -= currentRotationSpeed;
        }
        const totalRotation = -worldSphere.rotation.x;

        if (gameActive && !isPaused) update();

        // Skier roll away animation when game over (outside update so it continues)
        if (isGameOver) {
          skierRollAwayRotation += 0.05;
          playerGroup.rotation.x += 0.02;
          playerGroup.rotation.z += 0.03;
          playerGroup.position.y -= 0.1;
          // Rotate skier away
          player.rotation.x += 0.05;
          player.rotation.z += 0.08;
        }

        // Update skeleton once per frame if bones were modified (batched update)
        if (
          bonesDirty &&
          skierModel &&
          skierModel.children[0] &&
          skierModel.children[0].skeleton
        ) {
          // Often you can omit this entirely and Three.js will handle it during rendering
          // But keeping it for explicit control - only called ONCE per frame
          skierModel.children[0].skeleton.update();
          bonesDirty = false;
        }

        renderer.render(scene, camera);
      }

      function update() {
        // Gradually increase speed over time (very slight acceleration)
        if (currentRotationSpeed < CONFIG.maxSpeed) {
          currentRotationSpeed += CONFIG.accelerationRate;
          if (currentRotationSpeed > CONFIG.maxSpeed) {
            currentRotationSpeed = CONFIG.maxSpeed;
          }
        }

        const dx = targetX - player.position.x;
        player.position.x += dx * CONFIG.turnSpeed;

        if (isJumping) {
          verticalVelocity -= CONFIG.gravity;
          playerHeight += verticalVelocity;

          if (playerHeight <= 0) {
            playerHeight = 0;
            isJumping = false;
            verticalVelocity = 0;

            // Bones will be reset in updateJumpAnimation when it detects jump end
            // (wasJumping will be true, isJumping will be false)

            // Resume ambient sound when jump ends
            audio.ensureAmbient({
              gameActive,
              isPaused,
              isGameOver,
              isJumping,
            });
          }
        }
        player.position.y = CONFIG.worldRadius + playerHeight;

        const leanAmount = isJumping ? 0.05 : 0.15;
        player.rotation.z = -dx * leanAmount;
        if (isJumping) player.rotation.x = -0.5;
        else player.rotation.x = 0;

        // Get total rotation from world sphere (already updated in animate loop)
        const totalRotation = -worldSphere.rotation.x;

        // Only update score if game is active AND not game over
        // This prevents score accumulation during game over or restart
        if (gameActive && !isGameOver && !isPaused) {
          score += currentRotationSpeed * 100;
          document.getElementById("score").innerText = Math.floor(score);
        }

        // Only check collisions if game is active
        if (gameActive) {
          checkCollisions();
        }

        // Spawn Obstacles (only if game is active and not paused)
        // Keep same spawn rate on mobile to maintain game difficulty
        const spawnInterval = CONFIG.spawnInterval;
        const totalRotationForSpawn = -worldSphere.rotation.x;
        if (
          gameActive &&
          !isPaused &&
          totalRotationForSpawn - lastSpawnRotation > spawnInterval
        ) {
          // FIXED SPAWN ANGLE: 0.5 is closer to camera than 1.5.
          // 1.5 was spawning behind the new cleanup threshold.
          const spawnAngle = -worldSphere.rotation.x + 0.5;
          spawnRow(spawnAngle);
          lastSpawnRotation = totalRotationForSpawn;
        }

        // Spawn Boundaries (only if game is active and not paused)
        // Only spawn if instancers are ready
        const boundariesReady =
          fenceInstances && redSignInstances && blueSignInstances;
        if (boundariesReady) {
          // Reduce spawn rate by 15% on mobile (increase interval by ~18%) - less reduction for better visuals
          const boundaryInterval = isMobile()
            ? CONFIG.boundaryInterval * 1.18 // 15% reduction = 1/0.85 ‚âà 1.18x interval
            : CONFIG.boundaryInterval;
          if (
            gameActive &&
            !isPaused &&
            totalRotationForSpawn - lastBoundaryRotation > boundaryInterval
          ) {
            const bAngle = -worldSphere.rotation.x + 0.5;
            spawnBoundary(bAngle);
            lastBoundaryRotation = totalRotationForSpawn;
          }
        }

        // Spawn Gift (only if game is active, not paused, gift not collected)
        // Desktop: first gift at 1500m, then every 250m after that
        // Mobile: first gift at 1000m, then every 200m after that
        const isMobileDevice = isMobile();
        const firstGiftDistance = isMobileDevice ? 1000 : 1500;
        const giftInterval = isMobileDevice ? 200 : 250;

        if (
          gameActive &&
          !isPaused &&
          !giftCollected &&
          !activeGift &&
          score >= firstGiftDistance
        ) {
          const currentIntervalMark = Math.floor(
            (score - firstGiftDistance) / giftInterval
          );
          const lastIntervalMark = Math.floor(
            (lastGiftSpawnDistance - firstGiftDistance) / giftInterval
          );

          // Spawn gift when crossing into a new interval mark
          if (currentIntervalMark > lastIntervalMark) {
            const giftAngle = -worldSphere.rotation.x + 0.5;
            const playerAngle = -worldSphere.rotation.x;

            // Never spawn if angle window is too close to player
            if (Math.abs(playerAngle - giftAngle) >= 0.2) {
              // Far enough ahead, safe to spawn
              spawnGift(giftAngle);
              lastGiftSpawnDistance = score;
            }
            // If too close, skip this spawn attempt (will try again next interval)
          }
        }

        // Cleanup (only if not paused)
        if (!isPaused) {
          cleanupObjects();
        }
      }

      function cleanupObjects() {
        // On mobile, reduce cleanup frequency (every 3 frames instead of every frame)
        const isMobileDevice = isMobile();
        if (isMobileDevice) {
          cleanupCounter++;
          if (cleanupCounter % 3 !== 0) return; // Skip cleanup 2 out of 3 frames on mobile
        }

        const currentWorldAngle = -worldSphere.rotation.x;
        let needsMatrixUpdate = false;

        // Cleanup obstacles (trees)
        for (let i = activeObstacles.length - 1; i >= 0; i--) {
          const obj = activeObstacles[i];
          const angleDiff = currentWorldAngle - obj.angle;
          if (angleDiff > 1.5) {
            // Hide instance by scaling to near-zero
            if (treeInstances && obj.id !== undefined) {
              setOnSphereInstance(treeInstances, obj.id, 0, 0, 0.0001, 0);
              freeTreeIds.push(obj.id);
              needsMatrixUpdate = true;
            }
            activeObstacles.splice(i, 1);
          }
        }

        // Cleanup barriers (rocks)
        for (let i = activeBarriers.length - 1; i >= 0; i--) {
          const obj = activeBarriers[i];
          const angleDiff = currentWorldAngle - obj.angle;
          if (angleDiff > 1.5) {
            // Hide instance by scaling to near-zero
            if (rockInstances && obj.id !== undefined) {
              setOnSphereInstance(rockInstances, obj.id, 0, 0, 0.0001, 0);
              freeRockIds.push(obj.id);
              needsMatrixUpdate = true;
            }
            activeBarriers.splice(i, 1);
          }
        }

        // Cleanup boundaries (fences/signs)
        for (let i = activeBoundaries.length - 1; i >= 0; i--) {
          const obj = activeBoundaries[i];
          const angleDiff = currentWorldAngle - obj.angle;
          if (angleDiff > 1.5) {
            // Hide instance by scaling to near-zero
            if (obj.instancer && obj.id !== undefined) {
              setOnSphereInstance(obj.instancer, obj.id, 0, 0, 0.0001, 0);
              if (obj.type === "fence") {
                freeFenceIds.push(obj.id);
              } else if (obj.signType === "red") {
                freeRedSignIds.push(obj.id);
              } else if (obj.signType === "blue") {
                freeBlueSignIds.push(obj.id);
              }
              needsMatrixUpdate = true;
            }
            activeBoundaries.splice(i, 1);
          }
        }

        // Update instance matrices once after batch cleanup
        if (needsMatrixUpdate) {
          if (treeInstances) treeInstances.instanceMatrix.needsUpdate = true;
          if (rockInstances) rockInstances.instanceMatrix.needsUpdate = true;
          if (fenceInstances) fenceInstances.instanceMatrix.needsUpdate = true;
          if (redSignInstances)
            redSignInstances.instanceMatrix.needsUpdate = true;
          if (blueSignInstances)
            blueSignInstances.instanceMatrix.needsUpdate = true;
        }

        // Cleanup gift if it goes over horizon (angle-based check)
        if (activeGift) {
          const angleDiff = currentWorldAngle - activeGift.angle;
          if (angleDiff > 1.5) {
            // Gift expired without being collected - remove it but allow another to spawn
            activeGift.mesh.visible = false;
            worldSphere.remove(activeGift.mesh);
            activeGift = null;
            // Reset lastGiftSpawnDistance to current score minus one interval
            // This allows a new gift to spawn at the next interval mark
            const giftInterval = isMobileDevice ? 200 : 250;
            lastGiftSpawnDistance = Math.max(0, score - giftInterval);
            // Don't set giftCollected = true here - that's only for when player collects it
          }
        }

        // Limit max active objects on mobile
        if (isMobileDevice) {
          // Remove oldest obstacles if over limit
          while (activeObstacles.length > MAX_ACTIVE_OBSTACLES) {
            const obj = activeObstacles.shift();
            if (obj && treeInstances && obj.id !== undefined) {
              setOnSphereInstance(treeInstances, obj.id, 0, 0, 0.0001, 0);
              freeTreeIds.push(obj.id);
              treeInstances.instanceMatrix.needsUpdate = true;
            }
          }
          // Remove oldest barriers if over limit
          while (activeBarriers.length > MAX_ACTIVE_BARRIERS) {
            const obj = activeBarriers.shift();
            if (obj && rockInstances && obj.id !== undefined) {
              setOnSphereInstance(rockInstances, obj.id, 0, 0, 0.0001, 0);
              freeRockIds.push(obj.id);
              rockInstances.instanceMatrix.needsUpdate = true;
            }
          }
        }
      }

      function checkCollisions() {
        // On mobile, reduce collision check frequency (check every other frame)
        const isMobileDevice = isMobile();
        if (isMobileDevice) {
          collisionCheckCounter++;
          if (collisionCheckCounter % 2 === 0) return; // Skip every other frame on mobile
        }

        // Get player angle (angle-based collision detection - much faster!)
        const playerAngle = -worldSphere.rotation.x;
        player.getWorldPosition(_tempVec3);
        const pX = _tempVec3.x;

        // Gift collision (non-lethal) - use angle-based check
        if (activeGift && !giftCollected) {
          // Compare angles directly (no 3D vector math needed!)
          const angleDiff = Math.abs(playerAngle - activeGift.angle);

          // Only check collision if gift is close enough (don't exit entire function!)
          if (angleDiff <= 0.15 && angleDiff < 0.08) {
            // ~4.6 degrees - close enough to check X position
            activeGift.mesh.getWorldPosition(_tempVec3);
            if (Math.abs(_tempVec3.x - pX) < 1.5) {
              // Gift collected!
              audio.playSfx("twinkle");
              giftCollected = true;

              // Remove gift from scene
              worldSphere.remove(activeGift.mesh);
              activeGift = null;

              return; // OK to return here - gift was collected
            }
          }
          // If gift is too far away, just continue to check other collisions
        }

        // Trees - limit checks to nearby objects on mobile
        const maxObstacleChecks = isMobileDevice
          ? Math.min(activeObstacles.length, 10) // Only check closest 10 on mobile
          : activeObstacles.length;

        for (
          let i = activeObstacles.length - 1;
          i >= activeObstacles.length - maxObstacleChecks;
          i--
        ) {
          const obj = activeObstacles[i];

          // Angle-based early exit (much faster than getWorldPosition!)
          // Only check trees that are ahead of player's position (not behind)
          const angleDiff = playerAngle - obj.angle; // Positive = tree is ahead, negative = tree is behind

          // Aggressively skip trees that are behind or at the player (already passed)
          // Use strict threshold to prevent collisions when moving backward
          if (angleDiff <= 0.02) continue; // Tree is at or behind player (with small buffer), skip it completely

          // Early exit if tree is too far ahead (angle difference > ~0.08 radians ‚âà 4.6 degrees)
          if (angleDiff > 0.08) continue; // Skip if too far ahead

          // Skip decoration trees (they don't have lanes and shouldn't cause collisions)
          if (obj.lane === null || obj.lane === undefined) continue;

          // Only check X position if tree is clearly ahead and very close (within 0.03 radians ‚âà 1.7 degrees)
          // Very tight window to ensure tree is clearly ahead and prevent backward collisions
          // The tree's collision point might be slightly behind its angle, so we need a buffer
          if (angleDiff > 0.02 && angleDiff < 0.03) {
            // Calculate X position from lane (instanced objects don't have mesh.getWorldPosition)
            const treeX = obj.lane * CONFIG.laneWidth;
            if (Math.abs(treeX - pX) < 1.5) {
              triggerCrash();
              break; // Stop checking after collision
            }
          }
        }

        // Barriers - limit checks on mobile
        const maxBarrierChecks = isMobileDevice
          ? Math.min(activeBarriers.length, 5) // Only check closest 5 on mobile
          : activeBarriers.length;

        for (
          let i = activeBarriers.length - 1;
          i >= activeBarriers.length - maxBarrierChecks;
          i--
        ) {
          const obj = activeBarriers[i];

          // Angle-based early exit (much faster than getWorldPosition!)
          // For rocks, check slightly later (wider threshold) to give more time to jump
          const angleDiff = playerAngle - obj.angle; // Positive = barrier is ahead

          // Skip barriers that are behind the player (already passed)
          if (angleDiff < -0.05) continue; // Barrier is behind, skip it

          // Early exit if barrier is too far ahead (angle difference > ~0.1 radians ‚âà 5.7 degrees)
          if (angleDiff > 0.1) continue; // Skip if too far ahead

          // Skip if lane is invalid (shouldn't happen for rocks, but safety check)
          if (obj.lane === null || obj.lane === undefined) continue;

          // Only check X position when barrier is very close (within 0.03 radians ‚âà 1.7 degrees)
          // This gives player more time to jump before collision check
          if (!obj.passed && angleDiff >= -0.02 && angleDiff < 0.03) {
            // Calculate X position from lane (instanced objects don't have mesh.getWorldPosition)
            const rockX = obj.lane * CONFIG.laneWidth;
            if (Math.abs(rockX - pX) < 2.0) {
              // Easier to jump over: > 1.0 height required
              if (playerHeight > 1.0) {
                obj.passed = true;
                // No bonus points for jumping - just avoid crash
              } else {
                triggerCrash();
              }
              break; // Stop checking after collision
            }
          }
        }
      }

      function triggerCrash() {
        if (isGameOver || crashCooldown) return; // Don't process crashes if game is already over or in cooldown

        // Clear any existing cooldown timeout
        if (crashCooldownTimeout) {
          clearTimeout(crashCooldownTimeout);
          crashCooldownTimeout = null;
        }

        // Set cooldown to prevent multiple crashes
        crashCooldown = true;
        crashCooldownTimeout = setTimeout(() => {
          crashCooldown = false;
          crashCooldownTimeout = null;
        }, 1000); // 1 second cooldown

        // Decrement lives
        lives--;
        updateLivesDisplay();

        const overlay = document.getElementById("crash-overlay");
        overlay.style.opacity = 0.5;
        setTimeout(() => {
          overlay.style.opacity = 0;
        }, 100);

        // Start crash animation
        startCrashAnimation();

        // Play crash sound: ouch_3
        audio.playSfx("ouch3");

        // Check if game over
        if (lives <= 0) {
          gameOver();
        }
      }

      function gameOver() {
        isGameOver = true;
        gameActive = false;

        // Pause ambient ski noise
        audio.ensureAmbient({ gameActive, isPaused, isGameOver, isJumping });

        // Play game over sound
        audio.playSfx("ohNo");

        // Save high score
        saveHighScore();

        // Show game over screen
        const gameOverScreen = document.getElementById("game-over-screen");
        const finalScoreValue = document.getElementById("final-score-value");
        const claimGiftButton = document.getElementById("claim-gift-button");

        if (gameOverScreen && finalScoreValue) {
          finalScoreValue.textContent = Math.floor(score);
          gameOverScreen.classList.add("visible");

          // Show claim gift button only if gift was collected
          if (claimGiftButton && giftCollected) {
            claimGiftButton.style.display = "inline-block";
          } else if (claimGiftButton) {
            claimGiftButton.style.display = "none";
          }
        }
      }

      function togglePause() {
        if (isGameOver) return; // Can't pause when game is over

        isPaused = !isPaused;
        const pauseButton = document.getElementById("pause-button");
        if (pauseButton) {
          if (isPaused) {
            pauseButton.textContent = "‚ñ∂Ô∏è";
            pauseButton.title = "Resume";
            // Pause audio
            audio.ensureMusic();
            audio.ensureAmbient({
              gameActive,
              isPaused,
              isGameOver,
              isJumping,
            });
          } else {
            pauseButton.textContent = "‚è∏Ô∏è";
            pauseButton.title = "Pause";
            // Resume audio
            audio.ensureMusic();
            audio.ensureAmbient({
              gameActive,
              isPaused,
              isGameOver,
              isJumping,
            });
          }
        }
      }

      function restartGame() {
        // CRITICAL: Set gameActive to false FIRST to prevent score accumulation during reset
        gameActive = false;
        isGameOver = false;
        isPaused = false;

        // Reset game state
        lives = 3;
        score = 0;
        skierRollAwayRotation = 0;

        // Reset pause button
        const pauseButton = document.getElementById("pause-button");
        if (pauseButton) {
          pauseButton.textContent = "‚è∏Ô∏è";
          pauseButton.title = "Pause";
        }

        // Reset player position and rotation
        player.position.x = 0;
        player.position.y = CONFIG.worldRadius;
        player.rotation.x = 0;
        player.rotation.y = Math.PI;
        player.rotation.z = 0;
        playerGroup.rotation.x = 0;
        playerGroup.rotation.y = 0;
        playerGroup.rotation.z = 0;

        // Reset skier bones to skiing pose
        applySkiingPose();

        // Reset jump state
        isJumping = false;
        wasJumping = false; // Reset jump tracking
        verticalVelocity = 0;
        playerHeight = 0;

        // Reset crash state
        isCrashing = false;
        crashTime = 0;
        crashCooldown = false;
        // Clear any pending crash cooldown timeout
        if (crashCooldownTimeout) {
          clearTimeout(crashCooldownTimeout);
          crashCooldownTimeout = null;
        }

        // Reset turn states
        isRightTurning = false;
        isLeftTurning = false;
        rightTurnTime = 0;
        leftTurnTime = 0;

        // Reset lane
        currentLane = 0;
        targetX = 0;

        // Reset world rotation and speed BEFORE setting gameActive to true
        worldSphere.rotation.x = 0;
        currentRotationSpeed = CONFIG.baseSpeed;
        lastSpawnRotation = 0;
        lastBoundaryRotation = 0;

        // Reset animation time
        animationTime = 0;
        jumpAnimationTime = 0;
        crashTime = 0;
        rightTurnTime = 0;
        leftTurnTime = 0;

        // Clear obstacles - recycle IDs for instanced objects
        activeObstacles.forEach((obj) => {
          if (obj.id !== undefined && treeInstances) {
            setOnSphereInstance(treeInstances, obj.id, 0, 0, 0.0001, 0);
            freeTreeIds.push(obj.id);
          }
        });
        activeObstacles = [];

        activeBarriers.forEach((obj) => {
          if (obj.id !== undefined && rockInstances) {
            setOnSphereInstance(rockInstances, obj.id, 0, 0, 0.0001, 0);
            freeRockIds.push(obj.id);
          }
        });
        activeBarriers = [];

        activeBoundaries.forEach((obj) => {
          if (obj.id !== undefined && obj.instancer) {
            setOnSphereInstance(obj.instancer, obj.id, 0, 0, 0.0001, 0);
            if (obj.type === "fence") {
              freeFenceIds.push(obj.id);
            } else if (obj.signType === "red") {
              freeRedSignIds.push(obj.id);
            } else if (obj.signType === "blue") {
              freeBlueSignIds.push(obj.id);
            }
          }
        });
        activeBoundaries = [];

        // Update instance matrices
        if (treeInstances) treeInstances.instanceMatrix.needsUpdate = true;
        if (rockInstances) rockInstances.instanceMatrix.needsUpdate = true;
        if (fenceInstances) fenceInstances.instanceMatrix.needsUpdate = true;
        if (redSignInstances)
          redSignInstances.instanceMatrix.needsUpdate = true;
        if (blueSignInstances)
          blueSignInstances.instanceMatrix.needsUpdate = true;

        // Reset score display
        document.getElementById("score").innerText = "0";
        updateLivesDisplay();
        updateHighScoreDisplay();

        // Hide game over screen
        const gameOverScreen = document.getElementById("game-over-screen");
        const claimGiftButton = document.getElementById("claim-gift-button");
        if (gameOverScreen) {
          gameOverScreen.classList.remove("visible");
        }
        // Hide claim gift button on restart
        if (claimGiftButton) {
          claimGiftButton.style.display = "none";
        }

        // Resume ambient sound if enabled
        audio.ensureMusic();
        audio.ensureAmbient({ gameActive, isPaused, isGameOver, isJumping });

        // Reset gift state
        if (activeGift) {
          worldSphere.remove(activeGift.mesh);
        }
        activeGift = null;
        giftCollected = false;
        lastGiftSpawnDistance = 0;

        // Spawn initial trees and boundaries for new game
        spawnInitialTrees();

        // Ensure boundaries spawn if they weren't ready during initial spawn
        spawnInitialBoundariesIfNeeded();

        // FINALLY: Set gameActive to true AFTER everything is reset
        // This prevents score accumulation during the reset process
        gameActive = true;
      }

      function startCrashAnimation() {
        if (!boneParams.L_Thigh || !boneParams.R_Thigh || !boneParams.Head)
          return;

        // If crashing during a jump, reset jump animation state first
        if (isJumping) {
          isJumping = false;
          verticalVelocity = 0;
          playerHeight = 0;
          // Reset jump animation bones to skiing pose values
          if (boneParams.L_Upperarm) {
            boneParams.L_Upperarm.z = -1.03; // From skiing pose
            updateBoneRotation("L_Upperarm");
          }
          if (boneParams.R_Upperarm) {
            boneParams.R_Upperarm.z = 0.88; // From skiing pose
            updateBoneRotation("R_Upperarm");
          }
          if (boneParams.L_Thigh) {
            boneParams.L_Thigh.y = 0.01; // From skiing pose
            updateBoneRotation("L_Thigh");
          }
          if (boneParams.R_Thigh) {
            boneParams.R_Thigh.y = 0.03; // From skiing pose
            updateBoneRotation("R_Thigh");
          }
          // Reset jump base values to skiing pose
          lUpperarmBaseZ = -1.03;
          rUpperarmBaseZ = 0.88;
          lThighBaseY = 0.01;
          rThighBaseY = 0.03;
          jumpAnimationTime = 0;
        }

        // Store base values (current position)
        if (boneParams.Pelvis) crashBaseValues.pelvisZ = boneParams.Pelvis.z;
        if (boneParams.Hip) {
          crashBaseValues.hipX = boneParams.Hip.x;
          crashBaseValues.hipY = boneParams.Hip.y;
          crashBaseValues.hipZ = boneParams.Hip.z;
        }
        crashBaseValues.lThighY = boneParams.L_Thigh.y;
        crashBaseValues.lThighZ = boneParams.L_Thigh.z;
        crashBaseValues.rThighY = boneParams.R_Thigh.y;
        crashBaseValues.rThighZ = boneParams.R_Thigh.z;
        crashBaseValues.headZ = boneParams.Head.z;
        if (boneParams.R_Hand) crashBaseValues.rHandY = boneParams.R_Hand.y;
        if (boneParams.L_Hand) crashBaseValues.lHandY = boneParams.L_Hand.y;

        isCrashing = true;
        crashTime = 0;
      }

      function resetCrashAnimation() {
        if (!boneParams.L_Thigh || !boneParams.R_Thigh || !boneParams.Head)
          return;

        // Ensure jump state is reset
        if (isJumping) {
          isJumping = false;
          verticalVelocity = 0;
          playerHeight = 0;
        }

        // Reset jump animation base values to skiing pose
        lUpperarmBaseZ = -1.03;
        rUpperarmBaseZ = 0.88;
        lThighBaseY = 0.01;
        rThighBaseY = 0.03;
        jumpAnimationTime = 0;

        // Reset to skiing pose values (not crash base values, which may include animation offsets)
        // Use the same values from applySkiingPose()
        if (boneParams.Pelvis) {
          boneParams.Pelvis.z = -2.44;
          updateBoneRotation("Pelvis");
        }

        if (boneParams.Hip) {
          boneParams.Hip.x = 0.73;
          boneParams.Hip.y = -0.83;
          boneParams.Hip.z = -0.14;
          updateBoneRotation("Hip");
        }

        if (boneParams.L_Thigh) {
          boneParams.L_Thigh.y = 0.01;
          boneParams.L_Thigh.z = 0.6;
          updateBoneRotation("L_Thigh");
        }

        if (boneParams.R_Thigh) {
          boneParams.R_Thigh.y = 0.03;
          boneParams.R_Thigh.z = 0.6;
          updateBoneRotation("R_Thigh");
        }

        // Reset jump animation bones to skiing pose
        if (boneParams.L_Upperarm) {
          boneParams.L_Upperarm.z = -1.03;
          updateBoneRotation("L_Upperarm");
        }
        if (boneParams.R_Upperarm) {
          boneParams.R_Upperarm.z = 0.88;
          updateBoneRotation("R_Upperarm");
        }

        if (boneParams.Head) {
          boneParams.Head.z = 0;
          updateBoneRotation("Head");
        }

        if (boneParams.R_Hand) {
          boneParams.R_Hand.y = 0.38;
          updateBoneRotation("R_Hand");
        }

        if (boneParams.L_Hand) {
          boneParams.L_Hand.y = 0;
          updateBoneRotation("L_Hand");
        }

        isCrashing = false;
        crashTime = 0;
      }

      function updateCrashAnimation(deltaTime) {
        if (!isCrashing) return;

        crashTime += deltaTime * crashAnimationSpeed;
        const crashUpDuration = 0.3; // Time to go from base to crash position
        const crashDownDuration = 0.3; // Time to go from crash back to base
        const totalDuration = crashUpDuration + crashDownDuration;

        let progress = 0;
        if (crashTime < crashUpDuration) {
          const t = crashTime / crashUpDuration;
          progress = 1 - (1 - t) * (1 - t);
        } else if (crashTime < totalDuration) {
          const t = (crashTime - crashUpDuration) / crashDownDuration;
          progress = 1 - t * t;
        } else {
          resetCrashAnimation();
          return;
        }

        if (boneParams.Pelvis && skierBones.Pelvis) {
          boneParams.Pelvis.z =
            crashBaseValues.pelvisZ +
            (crashAnimationParams.pelvisZ - crashBaseValues.pelvisZ) * progress;
          updateBoneRotation("Pelvis");
        }

        if (boneParams.Hip && skierBones.Hip) {
          boneParams.Hip.x =
            crashBaseValues.hipX +
            (crashAnimationParams.hipX - crashBaseValues.hipX) * progress;
          boneParams.Hip.y =
            crashBaseValues.hipY +
            (crashAnimationParams.hipY - crashBaseValues.hipY) * progress;
          boneParams.Hip.z =
            crashBaseValues.hipZ +
            (crashAnimationParams.hipZ - crashBaseValues.hipZ) * progress;
          updateBoneRotation("Hip");
        }

        if (boneParams.L_Thigh && skierBones.L_Thigh) {
          boneParams.L_Thigh.y =
            crashBaseValues.lThighY +
            (crashAnimationParams.lThighY - crashBaseValues.lThighY) * progress;
          boneParams.L_Thigh.z =
            crashBaseValues.lThighZ +
            (crashAnimationParams.lThighZ - crashBaseValues.lThighZ) * progress;
          updateBoneRotation("L_Thigh");
        }

        if (boneParams.R_Thigh && skierBones.R_Thigh) {
          boneParams.R_Thigh.y =
            crashBaseValues.rThighY +
            (crashAnimationParams.rThighY - crashBaseValues.rThighY) * progress;
          boneParams.R_Thigh.z =
            crashBaseValues.rThighZ +
            (crashAnimationParams.rThighZ - crashBaseValues.rThighZ) * progress;
          updateBoneRotation("R_Thigh");
        }

        if (boneParams.Head && skierBones.Head) {
          boneParams.Head.z =
            crashBaseValues.headZ +
            (crashAnimationParams.headZ - crashBaseValues.headZ) * progress;
          updateBoneRotation("Head");
        }

        if (boneParams.R_Hand && skierBones.R_Hand) {
          boneParams.R_Hand.y =
            crashBaseValues.rHandY +
            (crashAnimationParams.rHandY - crashBaseValues.rHandY) * progress;
          updateBoneRotation("R_Hand");
        }

        if (boneParams.L_Hand && skierBones.L_Hand) {
          boneParams.L_Hand.y =
            crashBaseValues.lHandY +
            (crashAnimationParams.lHandY - crashBaseValues.lHandY) * progress;
          updateBoneRotation("L_Hand");
        }
      }

      function showJumpMsg() {
        const msg = document.getElementById("jump-msg");
        msg.style.opacity = 1;
        msg.style.top = "30%";
        setTimeout(() => {
          msg.style.opacity = 0;
          msg.style.top = "40%";
        }, 500);
      }

      function resetGame() {
        // Recycle IDs for instanced objects
        activeObstacles.forEach((obj) => {
          if (obj.id !== undefined && treeInstances) {
            setOnSphereInstance(treeInstances, obj.id, 0, 0, 0.0001, 0);
            freeTreeIds.push(obj.id);
          }
        });
        activeBarriers.forEach((obj) => {
          if (obj.id !== undefined && rockInstances) {
            setOnSphereInstance(rockInstances, obj.id, 0, 0, 0.0001, 0);
            freeRockIds.push(obj.id);
          }
        });
        activeBoundaries.forEach((obj) => {
          if (obj.id !== undefined && obj.instancer) {
            setOnSphereInstance(obj.instancer, obj.id, 0, 0, 0.0001, 0);
            if (obj.type === "fence") {
              freeFenceIds.push(obj.id);
            } else if (obj.signType === "red") {
              freeRedSignIds.push(obj.id);
            } else if (obj.signType === "blue") {
              freeBlueSignIds.push(obj.id);
            }
          }
        });
        if (activeGift) {
          worldSphere.remove(activeGift.mesh);
        }
        activeObstacles = [];
        activeBarriers = [];
        activeBoundaries = [];
        activeGift = null;
        giftCollected = false;

        // Update instance matrices
        if (treeInstances) treeInstances.instanceMatrix.needsUpdate = true;
        if (rockInstances) rockInstances.instanceMatrix.needsUpdate = true;
        if (fenceInstances) fenceInstances.instanceMatrix.needsUpdate = true;
        if (redSignInstances)
          redSignInstances.instanceMatrix.needsUpdate = true;
        if (blueSignInstances)
          blueSignInstances.instanceMatrix.needsUpdate = true;
        lastGiftSpawnDistance = 0;

        player.position.x = 0;
        targetX = 0;
        currentLane = 0;
        score = 0;
        currentRotationSpeed = CONFIG.baseSpeed;
        worldSphere.rotation.x = 0;
        lastSpawnRotation = 0;
        lastBoundaryRotation = 0;

        for (let i = 0; i < 30; i++) {
          let angle = 0.5 - i * 0.05;
          spawnTree(angle, true);
          spawnBoundary(angle);
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function moveLane(direction) {
        if (!gameActive || isGameOver || isPaused) return;
        currentLane += direction;
        if (currentLane < -1) currentLane = -1;
        if (currentLane > 1) currentLane = 1;
        targetX = currentLane * CONFIG.laneWidth;

        // Start turn animation
        if (direction > 0) {
          startRightTurn();
          audio.playSfx("rightTurn");
          audio.playSfx("thump");
        } else if (direction < 0) {
          startLeftTurn();
          audio.playSfx("leftTurn");
          audio.playSfx("thump");
        }

        // Initialize audio on first interaction
        if (typeof initAudioOnInteraction === "function") {
          initAudioOnInteraction();
        }
      }

      function startRightTurn() {
        if (!boneParams.Pelvis || !boneParams.Head) return;
        // Store current values (which include base animation offset)
        rightTurnBaseValues.pelvisY = boneParams.Pelvis.y;
        rightTurnBaseValues.headY = boneParams.Head.y;
        isRightTurning = true;
        rightTurnTime = 0;
      }

      function startLeftTurn() {
        if (!boneParams.Pelvis || !boneParams.Head) return;
        // Store current values (which include base animation offset)
        leftTurnBaseValues.pelvisY = boneParams.Pelvis.y;
        leftTurnBaseValues.headY = boneParams.Head.y;
        isLeftTurning = true;
        leftTurnTime = 0;
      }

      function updateRightTurnAnimation(deltaTime) {
        if (!isRightTurning) return;

        rightTurnTime += deltaTime * rightTurnSpeed;
        const turnUpDuration = 0.2;
        const turnDownDuration = 0.2;
        const totalDuration = turnUpDuration + turnDownDuration;

        let progress = 0;
        if (rightTurnTime < turnUpDuration) {
          const t = rightTurnTime / turnUpDuration;
          progress = 1 - (1 - t) * (1 - t);
        } else if (rightTurnTime < totalDuration) {
          const t = (rightTurnTime - turnUpDuration) / turnDownDuration;
          progress = 1 - t * t;
        } else {
          isRightTurning = false;
          rightTurnTime = 0;
          return;
        }

        if (boneParams.Pelvis && skierBones.Pelvis) {
          // Interpolate from base to turn position
          boneParams.Pelvis.y =
            animationParams.pelvis.baseY +
            (rightTurnParams.pelvisY - animationParams.pelvis.baseY) * progress;
          updateBoneRotation("Pelvis");
        }

        if (boneParams.Head && skierBones.Head) {
          // Interpolate from base to turn position
          boneParams.Head.y =
            animationParams.head.baseY +
            (rightTurnParams.headY - animationParams.head.baseY) * progress;
          updateBoneRotation("Head");
        }
      }

      function updateLeftTurnAnimation(deltaTime) {
        if (!isLeftTurning) return;

        leftTurnTime += deltaTime * leftTurnSpeed;
        const turnUpDuration = 0.2;
        const turnDownDuration = 0.2;
        const totalDuration = turnUpDuration + turnDownDuration;

        let progress = 0;
        if (leftTurnTime < turnUpDuration) {
          const t = leftTurnTime / turnUpDuration;
          progress = 1 - (1 - t) * (1 - t);
        } else if (leftTurnTime < totalDuration) {
          const t = (leftTurnTime - turnUpDuration) / turnDownDuration;
          progress = 1 - t * t;
        } else {
          isLeftTurning = false;
          leftTurnTime = 0;
          return;
        }

        if (boneParams.Pelvis && skierBones.Pelvis) {
          // Interpolate from base to turn position
          boneParams.Pelvis.y =
            animationParams.pelvis.baseY +
            (leftTurnParams.pelvisY - animationParams.pelvis.baseY) * progress;
          updateBoneRotation("Pelvis");
        }

        if (boneParams.Head && skierBones.Head) {
          // Interpolate from base to turn position
          boneParams.Head.y =
            animationParams.head.baseY +
            (leftTurnParams.headY - animationParams.head.baseY) * progress;
          updateBoneRotation("Head");
        }
      }

      function jump() {
        if (!gameActive || isGameOver || isPaused) return;
        if (!isJumping) {
          isJumping = true;
          verticalVelocity = CONFIG.jumpStrength;

          // Pause ambient sound during jump
          audio.ensureAmbient({ gameActive, isPaused, isGameOver, isJumping });

          // Start jump animation
          startJumpAnimation();
          audio.playSfx("jump");
        }
      }

      function startJumpAnimation() {
        if (!boneParams.L_Upperarm || !boneParams.R_Upperarm) return;

        // Store base values (current position)
        lUpperarmBaseZ = boneParams.L_Upperarm.z;
        rUpperarmBaseZ = boneParams.R_Upperarm.z;
        if (boneParams.L_Thigh) lThighBaseY = boneParams.L_Thigh.y;
        if (boneParams.R_Thigh) rThighBaseY = boneParams.R_Thigh.y;

        jumpAnimationTime = 0;
      }

      function updateJumpAnimation(deltaTime) {
        // Only reset bones once when jump ends (not every frame)
        if (!isJumping && wasJumping) {
          // Jump just ended - reset bones to base values once
          setBoneZ("L_Upperarm", lUpperarmBaseZ);
          setBoneZ("R_Upperarm", rUpperarmBaseZ);
          setBoneY("L_Thigh", lThighBaseY);
          setBoneY("R_Thigh", rThighBaseY);
          wasJumping = false;
          return;
        }

        // If not jumping and wasn't jumping before, do nothing
        if (!isJumping) {
          wasJumping = false;
          return;
        }

        // Track that we're jumping
        wasJumping = true;

        jumpAnimationTime += deltaTime * jumpAnimationSpeed;
        const jumpUpDuration = 0.3; // Time to go from base to jump position
        const jumpDownDuration = 0.3; // Time to go from jump back to base
        const totalDuration = jumpUpDuration + jumpDownDuration;

        let progress = 0;

        if (jumpAnimationTime < jumpUpDuration) {
          // Phase 1: Going up (base ‚Üí jump position)
          const t = jumpAnimationTime / jumpUpDuration;
          // Ease out for going up
          progress = 1 - (1 - t) * (1 - t);
        } else if (jumpAnimationTime < totalDuration) {
          // Phase 2: Going down (jump position ‚Üí base)
          const t = (jumpAnimationTime - jumpUpDuration) / jumpDownDuration;
          // Ease in for going down
          progress = 1 - t * t;
        } else {
          // Animation complete - reset to base
          progress = 0;
        }

        if (boneParams.L_Upperarm && skierBones.L_Upperarm) {
          boneParams.L_Upperarm.z =
            lUpperarmBaseZ +
            (jumpAnimationParams.lUpperarmZ - lUpperarmBaseZ) * progress;
          updateBoneRotation("L_Upperarm");
        }

        if (boneParams.R_Upperarm && skierBones.R_Upperarm) {
          boneParams.R_Upperarm.z =
            rUpperarmBaseZ +
            (jumpAnimationParams.rUpperarmZ - rUpperarmBaseZ) * progress;
          updateBoneRotation("R_Upperarm");
        }

        if (boneParams.L_Thigh && skierBones.L_Thigh) {
          boneParams.L_Thigh.y =
            lThighBaseY +
            (jumpAnimationParams.lThighY - lThighBaseY) * progress;
          updateBoneRotation("L_Thigh");
        }

        if (boneParams.R_Thigh && skierBones.R_Thigh) {
          boneParams.R_Thigh.y =
            rThighBaseY +
            (jumpAnimationParams.rThighY - rThighBaseY) * progress;
          updateBoneRotation("R_Thigh");
        }
      }

      function onKeyDown(event) {
        if (event.key === "ArrowLeft" || event.key === "a") moveLane(-1);
        if (event.key === "ArrowRight" || event.key === "d") moveLane(1);
        if (event.key === "ArrowUp" || event.key === " " || event.key === "w")
          jump();
      }

      function setupSwipeControls() {
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        // Prevent context menu on long press (mobile)
        document.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          return false;
        });

        document.addEventListener(
          "touchstart",
          (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
          },
          { passive: false }
        );

        document.addEventListener(
          "touchend",
          (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
          },
          { passive: false }
        );

        function handleSwipe() {
          const dx = touchEndX - touchStartX;
          const dy = touchEndY - touchStartY;

          if (Math.abs(dx) > Math.abs(dy)) {
            if (Math.abs(dx) > 40) {
              if (dx < 0) moveLane(-1);
              else moveLane(1);
            }
          } else {
            if (dy < -40) {
              jump();
            }
          }
        }
      }

      init();
    </script>
  </body>
</html>
