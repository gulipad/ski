<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Alpine Rush: Pro Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
      /* CSS Reset */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        touch-action: none;
        user-select: none;
      }

      body {
        overflow: hidden;
        background: linear-gradient(to bottom, #87ceeb, #e0f7fa);
        font-family: "Segoe UI", monospace;
      }

      /* UI Layer */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 20px;
      }

      #score-board {
        text-align: center;
        color: #333;
        text-shadow: 0 0 2px white;
      }

      #score {
        font-size: 3rem;
        font-weight: 800;
        color: #2c3e50;
      }

      #label {
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: #555;
        font-weight: bold;
      }

      /* Debug Panel */
      #debug-panel {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 280px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 8px;
        pointer-events: auto;
        font-size: 0.9rem;
        z-index: 100;
        overflow: hidden;
        transition: height 0.3s ease;
      }

      #skier-panel {
        position: absolute;
        top: 350px;
        right: 10px;
        width: 280px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border-radius: 8px;
        pointer-events: auto;
        font-size: 0.9rem;
        z-index: 100;
        overflow: hidden;
        transition: height 0.3s ease;
      }

      #debug-header {
        padding: 15px;
        background: rgba(255, 255, 255, 0.1);
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        user-select: none;
      }

      #debug-header h3 {
        margin: 0;
        color: #f1c40f;
        font-size: 1rem;
      }

      #debug-content {
        padding: 15px;
        display: block;
      }

      #debug-panel.collapsed #debug-content {
        display: none;
      }

      #skier-panel.collapsed #skier-content {
        display: none;
      }

      .control-group {
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .control-group label {
        width: 60px;
      }
      .control-group input {
        width: 140px;
      }
      .control-group span {
        width: 40px;
        text-align: right;
        font-size: 0.8rem;
        color: #ccc;
      }

      #camera-readout {
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #555;
        font-size: 0.75rem;
        line-height: 1.4;
        color: #87ceeb;
        user-select: text;
      }

      /* Crash Effect */
      #crash-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: red;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.1s;
        mix-blend-mode: overlay;
      }

      #jump-msg {
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #f1c40f;
        font-weight: 900;
        font-size: 2rem;
        text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s;
      }
    </style>
  </head>
  <body>
    <div id="crash-overlay"></div>
    <div id="jump-msg">JUMP!</div>

    <!-- Camera Debug Panel -->
    <div id="debug-panel" class="collapsed">
      <!-- Default to collapsed -->
      <div id="debug-header">
        <h3>Camera Controls</h3>
        <span id="toggle-icon">▼</span>
      </div>
      <div id="debug-content">
        <div class="control-group">
          <label>Pos Y</label>
          <input type="range" id="camY" min="50" max="200" step="1" />
          <span id="valY">0</span>
        </div>
        <div class="control-group">
          <label>Pos Z</label>
          <input type="range" id="camZ" min="0" max="100" step="1" />
          <span id="valZ">0</span>
        </div>

        <hr style="border: 0; border-top: 1px solid #555; margin: 10px 0" />

        <div class="control-group">
          <label>Look Y</label>
          <input type="range" id="lookY" min="0" max="150" step="1" />
          <span id="valLookY">0</span>
        </div>
        <div class="control-group">
          <label>Look Z</label>
          <input type="range" id="lookZ" min="-50" max="50" step="1" />
          <span id="valLookZ">0</span>
        </div>

        <div class="control-group">
          <label>FOV</label>
          <input type="range" id="camFov" min="10" max="120" step="1" />
          <span id="valFov">0</span>
        </div>

        <div id="camera-readout">Values will appear here...</div>
      </div>
    </div>

    <!-- Skier Debug Panel -->
    <div id="skier-panel">
      <div id="skier-header">
        <h3>Skier Controls</h3>
        <span id="skier-toggle-icon">▲</span>
      </div>
      <div id="skier-content">
        <div class="control-group">
          <label>Scale</label>
          <input type="range" id="skierScale" min="0.5" max="10" step="0.1" />
          <span id="valSkierScale">3.0</span>
        </div>

        <hr style="border: 0; border-top: 1px solid #555; margin: 10px 0" />

        <div class="control-group">
          <label>Pos X</label>
          <input type="range" id="skierX" min="-5" max="5" step="0.1" />
          <span id="valSkierX">0</span>
        </div>
        <div class="control-group">
          <label>Pos Y</label>
          <input type="range" id="skierY" min="-5" max="5" step="0.1" />
          <span id="valSkierY">0</span>
        </div>
        <div class="control-group">
          <label>Pos Z</label>
          <input type="range" id="skierZ" min="-5" max="5" step="0.1" />
          <span id="valSkierZ">0</span>
        </div>

        <hr style="border: 0; border-top: 1px solid #555; margin: 10px 0" />

        <div class="control-group">
          <label>Rot X</label>
          <input
            type="range"
            id="skierRotX"
            min="-3.14"
            max="3.14"
            step="0.1"
          />
          <span id="valSkierRotX">0</span>
        </div>
        <div class="control-group">
          <label>Rot Y</label>
          <input
            type="range"
            id="skierRotY"
            min="-3.14"
            max="3.14"
            step="0.1"
          />
          <span id="valSkierRotY">0</span>
        </div>
        <div class="control-group">
          <label>Rot Z</label>
          <input
            type="range"
            id="skierRotZ"
            min="-3.14"
            max="3.14"
            step="0.1"
          />
          <span id="valSkierRotZ">0</span>
        </div>

        <div
          id="skier-readout"
          style="
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #555;
            font-size: 0.75rem;
            line-height: 1.4;
            color: #87ceeb;
            user-select: text;
          "
        >
          Values will appear here...
        </div>

        <div
          id="bone-controls"
          style="
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #555;
            display: none;
          "
        >
          <div
            style="
              font-size: 0.85rem;
              color: #f1c40f;
              margin-bottom: 10px;
              font-weight: bold;
            "
          >
            Bone Controls
          </div>
          <button
            id="apply-skiing-pose"
            style="
              width: 100%;
              padding: 8px;
              margin-bottom: 10px;
              background: #27ae60;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 0.85rem;
              font-weight: bold;
            "
          >
            Apply Skiing Pose
          </button>
          <div id="bone-controls-content"></div>
        </div>
      </div>
    </div>

    <div id="ui-layer">
      <div id="score-board">
        <div id="score">0</div>
        <div id="label">Meters</div>
      </div>
    </div>

    <script>
      // --- CONFIGURATION ---
      const CONFIG = {
        baseSpeed: 0.003,
        maxSpeed: 0.003,
        turnSpeed: 0.25,
        worldRadius: 100,
        spawnInterval: 0.18,
        boundaryInterval: 0.08,
        laneWidth: 5,
        gravity: 0.06, // Slightly higher gravity for snappier jumps
        jumpStrength: 0.9, // Lower jump (was 1.2)
        fogColor: 0x87ceeb,
        groundColor: 0xffffff,
      };

      // --- GLOBAL VARIABLES ---
      let scene, camera, renderer;
      let player, playerGroup;
      let worldSphere;
      let particlesSystem;

      // Animation
      let mixer;
      let clock = new THREE.Clock();
      let skierModel;
      let skierBaseOffset = { x: 0, y: 0, z: 0 };
      let skierBones = {}; // Store bone references for manipulation

      let gameActive = true;
      let score = 0;
      let currentRotationSpeed = CONFIG.baseSpeed;

      let currentLane = 0;
      let targetX = 0;

      let isJumping = false;
      let verticalVelocity = 0;
      let playerHeight = 0;

      let lastSpawnRotation = 0;
      let lastBoundaryRotation = 0;
      let boundaryAlternator = 0;

      let activeObstacles = [];
      let activeBarriers = [];
      let activeBoundaries = [];

      // Camera State (User Values applied here)
      let camParams = {
        y: 112,
        z: 33,
        lookY: 90,
        lookZ: -13,
        fov: 44,
      };

      // Skier Transform State
      let skierParams = {
        scale: 3.5,
        posX: -0.2,
        posY: 0.6,
        posZ: -0.3,
        rotX: 0.06,
        rotY: 3.06,
        rotZ: -0.04,
      };

      // Bone rotation state
      let boneParams = {};

      // --- HELPER: TEXTURES ---
      function getParticleTexture() {
        const canvas = document.createElement("canvas");
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext("2d");
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
        gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
      }

      // --- INITIALIZATION ---
      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.fogColor);
        scene.fog = new THREE.Fog(CONFIG.fogColor, 60, 120);

        camera = new THREE.PerspectiveCamera(
          camParams.fov,
          window.innerWidth / window.innerHeight,
          0.1,
          300
        );
        updateCamera();

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(20, 80, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 200;
        dirLight.shadow.camera.left = -50;
        dirLight.shadow.camera.right = 50;
        dirLight.shadow.camera.top = 50;
        dirLight.shadow.camera.bottom = -50;
        scene.add(dirLight);

        // Add a subtle fill light from the front for better model visibility
        const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.4);
        fillLight.position.set(0, 30, 100);
        scene.add(fillLight);

        // Add hemisphere light for natural sky/ground lighting
        const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0xffffff, 0.3);
        scene.add(hemiLight);

        const sphereGeo = new THREE.SphereGeometry(CONFIG.worldRadius, 64, 64);
        const sphereMat = new THREE.MeshLambertMaterial({
          color: CONFIG.groundColor,
        });
        worldSphere = new THREE.Mesh(sphereGeo, sphereMat);
        worldSphere.receiveShadow = true;
        scene.add(worldSphere);

        createPlayer();
        createParticleSystem();

        window.addEventListener("resize", onWindowResize, false);
        document.addEventListener("keydown", onKeyDown, false);
        setupSwipeControls();
        setupDebugControls();
        setupSkierControls();

        // Initial Objects
        // Spawn ahead of player so they are visible immediately
        for (let i = 0; i < 30; i++) {
          // Spawn angle: 0.5 down to -1.0 (covering visible range)
          let angle = 0.5 - i * 0.05;
          spawnTree(angle, true);
          spawnBoundary(angle);
        }

        animate();
      }

      function setupDebugControls() {
        const header = document.getElementById("debug-header");
        const panel = document.getElementById("debug-panel");
        const icon = document.getElementById("toggle-icon");

        header.addEventListener("click", () => {
          panel.classList.toggle("collapsed");
          icon.innerText = panel.classList.contains("collapsed") ? "▼" : "▲";
        });

        document.getElementById("camY").value = camParams.y;
        document.getElementById("camZ").value = camParams.z;
        document.getElementById("lookY").value = camParams.lookY;
        document.getElementById("lookZ").value = camParams.lookZ;
        document.getElementById("camFov").value = camParams.fov;

        updateDebugDisplay();

        const inputs = ["camY", "camZ", "lookY", "lookZ", "camFov"];
        inputs.forEach((id) => {
          document.getElementById(id).addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            if (id === "camY") camParams.y = val;
            if (id === "camZ") camParams.z = val;
            if (id === "lookY") camParams.lookY = val;
            if (id === "lookZ") camParams.lookZ = val;
            if (id === "camFov") camParams.fov = val;
            updateCamera();
            updateDebugDisplay();
          });
        });
      }

      function updateCamera() {
        camera.position.set(0, camParams.y, camParams.z);
        camera.lookAt(0, camParams.lookY, camParams.lookZ);
        camera.fov = camParams.fov;
        camera.updateProjectionMatrix();
      }

      function updateDebugDisplay() {
        document.getElementById("valY").innerText = camParams.y;
        document.getElementById("valZ").innerText = camParams.z;
        document.getElementById("valLookY").innerText = camParams.lookY;
        document.getElementById("valLookZ").innerText = camParams.lookZ;
        document.getElementById("valFov").innerText = camParams.fov;

        const txt = `
camera.position.set(0, ${camParams.y}, ${camParams.z});<br>
camera.lookAt(0, ${camParams.lookY}, ${camParams.lookZ});<br>
fov: ${camParams.fov}
            `;
        document.getElementById("camera-readout").innerHTML = txt;
      }

      function setupSkierControls() {
        const header = document.getElementById("skier-header");
        const panel = document.getElementById("skier-panel");
        const icon = document.getElementById("skier-toggle-icon");

        header.addEventListener("click", () => {
          panel.classList.toggle("collapsed");
          icon.innerText = panel.classList.contains("collapsed") ? "▼" : "▲";
        });

        // Set initial values
        document.getElementById("skierScale").value = skierParams.scale;
        document.getElementById("skierX").value = skierParams.posX;
        document.getElementById("skierY").value = skierParams.posY;
        document.getElementById("skierZ").value = skierParams.posZ;
        document.getElementById("skierRotX").value = skierParams.rotX;
        document.getElementById("skierRotY").value = skierParams.rotY;
        document.getElementById("skierRotZ").value = skierParams.rotZ;

        updateSkierDisplay();

        // Setup event listeners
        document.getElementById("skierScale").addEventListener("input", (e) => {
          skierParams.scale = parseFloat(e.target.value);
          updateSkierTransform();
          updateSkierDisplay();
        });

        ["skierX", "skierY", "skierZ"].forEach((id) => {
          document.getElementById(id).addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            if (id === "skierX") skierParams.posX = val;
            if (id === "skierY") skierParams.posY = val;
            if (id === "skierZ") skierParams.posZ = val;
            updateSkierTransform();
            updateSkierDisplay();
          });
        });

        ["skierRotX", "skierRotY", "skierRotZ"].forEach((id) => {
          document.getElementById(id).addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            if (id === "skierRotX") skierParams.rotX = val;
            if (id === "skierRotY") skierParams.rotY = val;
            if (id === "skierRotZ") skierParams.rotZ = val;
            updateSkierTransform();
            updateSkierDisplay();
          });
        });
      }

      function updateSkierTransform() {
        if (skierModel) {
          skierModel.scale.set(
            skierParams.scale,
            skierParams.scale,
            skierParams.scale
          );
          skierModel.position.x = skierBaseOffset.x + skierParams.posX;
          skierModel.position.y = skierBaseOffset.y + skierParams.posY;
          skierModel.position.z = skierBaseOffset.z + skierParams.posZ;
          skierModel.rotation.x = skierParams.rotX;
          skierModel.rotation.y = skierParams.rotY;
          skierModel.rotation.z = skierParams.rotZ;
        }
      }

      function setupBoneControls(boneNames) {
        const boneControlsDiv = document.getElementById("bone-controls");
        const boneControlsContent = document.getElementById(
          "bone-controls-content"
        );

        // Show the bone controls section
        boneControlsDiv.style.display = "block";

        // Setup skiing pose button
        const skiingPoseBtn = document.getElementById("apply-skiing-pose");
        if (skiingPoseBtn) {
          skiingPoseBtn.addEventListener("click", applySkiingPose);
        }

        // Filter for common body parts (arms, legs, head, etc.)
        // Include bones with L_ or R_ prefix and main body bones
        const relevantBones = boneNames.filter((name) => {
          const lower = name.toLowerCase();
          // Include main bones (skip twist bones for cleaner UI)
          return (
            (lower.includes("arm") && !lower.includes("twist")) ||
            (lower.includes("hand") && !lower.includes("twist")) ||
            (lower.includes("thigh") && !lower.includes("twist")) ||
            (lower.includes("calf") && !lower.includes("twist")) ||
            (lower.includes("foot") && !lower.includes("twist")) ||
            lower.includes("head") ||
            lower.includes("neck") ||
            lower.includes("clavicle") ||
            lower.includes("spine") ||
            lower.includes("waist") ||
            lower.includes("pelvis") ||
            lower.includes("hip")
          );
        });

        // If no obvious body parts, show main bones (skip twist bones)
        const bonesToShow =
          relevantBones.length > 0
            ? relevantBones
            : boneNames
                .filter((n) => !n.toLowerCase().includes("twist"))
                .slice(0, 15);

        bonesToShow.forEach((boneName) => {
          // Initialize bone params
          if (!boneParams[boneName]) {
            boneParams[boneName] = { x: 0, y: 0, z: 0 };
          }

          // Create bone control group
          const boneGroup = document.createElement("div");
          boneGroup.style.marginBottom = "12px";
          boneGroup.style.paddingBottom = "8px";
          boneGroup.style.borderBottom = "1px solid #444";

          const boneTitle = document.createElement("div");
          boneTitle.style.fontSize = "0.8rem";
          boneTitle.style.color = "#f1c40f";
          boneTitle.style.marginBottom = "5px";
          boneTitle.style.fontWeight = "bold";
          boneTitle.textContent = boneName;
          boneGroup.appendChild(boneTitle);

          // Create rotation controls for X, Y, Z
          ["X", "Y", "Z"].forEach((axis) => {
            const controlGroup = document.createElement("div");
            controlGroup.className = "control-group";
            controlGroup.style.marginBottom = "4px";

            const label = document.createElement("label");
            label.textContent = `Rot ${axis}`;
            label.style.width = "60px";
            controlGroup.appendChild(label);

            const input = document.createElement("input");
            input.type = "range";
            input.id = `bone_${boneName}_${axis}`;
            input.min = "-1.57";
            input.max = "1.57";
            input.step = "0.05";
            input.value = boneParams[boneName][axis.toLowerCase()];
            input.style.width = "140px";
            controlGroup.appendChild(input);

            const span = document.createElement("span");
            span.id = `val_bone_${boneName}_${axis}`;
            span.textContent = "0.00";
            span.style.width = "40px";
            span.style.textAlign = "right";
            span.style.fontSize = "0.8rem";
            span.style.color = "#ccc";
            controlGroup.appendChild(span);

            boneGroup.appendChild(controlGroup);

            // Add event listener
            input.addEventListener("input", (e) => {
              const val = parseFloat(e.target.value);
              boneParams[boneName][axis.toLowerCase()] = val;
              updateBoneRotation(boneName);
              span.textContent = val.toFixed(2);
            });
          });

          boneControlsContent.appendChild(boneGroup);
        });
      }

      function applySkiingPose() {
        // Natural skiing pose - arms forward holding poles, legs bent, body leaning forward
        const skiingPose = {
          Root: { x: -1.57, y: 0.0, z: 1.57 },
          Hip: { x: 0.73, y: -0.83, z: -0.14 },
          Pelvis: { x: -2.2, y: -0.65, z: -2.44 },
          L_Thigh: { x: -3.06, y: 0.01, z: 0.6 },
          L_Calf: { x: 0.01, y: -0.01, z: -0.96 },
          L_Foot: { x: 1.02, y: 0.42, z: 1.5 },
          L_CalfTwist01: { x: -0.0, y: 0.0, z: -0.0 },
          L_CalfTwist02: { x: -0.0, y: 0.0, z: 0.0 },
          L_ThighTwist01: { x: 0.0, y: 0.0, z: -0.0 },
          L_ThighTwist02: { x: 0.0, y: -0.0, z: 0.0 },
          R_Thigh: { x: -2.88, y: 0.03, z: 0.6 },
          R_ThighTwist01: { x: 0.0, y: -0.0, z: -0.0 },
          R_ThighTwist02: { x: -0.0, y: -0.0, z: 0.0 },
          R_Calf: { x: -0.22, y: 0.11, z: -0.8 },
          R_Foot: { x: 1.12, y: 0.31, z: 1.4 },
          R_CalfTwist01: { x: 0.0, y: -0.0, z: 0.0 },
          R_CalfTwist02: { x: -0.0, y: -0.0, z: 0.0 },
          Waist: { x: -2.2, y: -0.65, z: -2.44 },
          Spine01: { x: -0.0, y: -0.0, z: -0.0 },
          Spine02: { x: 0.0, y: 0.0, z: 0.0 },
          NeckTwist01: { x: 0.0, y: -0.0, z: -0.0 },
          NeckTwist02: { x: 0.0, y: 0.0, z: 0.0 },
          Head: { x: -0.0, y: -0.37, z: -0.0 },
          L_Clavicle: { x: -2.37, y: -1.39, z: 2.39 },
          L_Upperarm: { x: 0.36, y: -0.0, z: -1.03 },
          L_Forearm: { x: 1.22, y: 0.99, z: -0.27 },
          L_ForearmTwist01: { x: -0.0, y: -0.0, z: -0.0 },
          L_ForearmTwist02: { x: 0.0, y: -0.0, z: 0.0 },
          L_Hand: { x: -0.0, y: -0.0, z: 0.0 },
          L_UpperarmTwist01: { x: 0.0, y: 0.0, z: -0.0 },
          L_UpperarmTwist02: { x: 0.0, y: 0.0, z: 0.0 },
          R_Clavicle: { x: -2.24, y: -1.41, z: -0.84 },
          R_Upperarm: { x: -0.57, y: -0.11, z: 0.81 },
          R_UpperarmTwist01: { x: -0.0, y: -0.0, z: -0.0 },
          R_UpperarmTwist02: { x: -0.0, y: -0.0, z: 0.0 },
          R_Forearm: { x: 0.97, y: -0.54, z: 0.66 },
          R_ForearmTwist01: { x: 0.0, y: -0.0, z: 0.0 },
          R_ForearmTwist02: { x: -0.0, y: 0.0, z: -0.0 },
          R_Hand: { x: -0.0, y: -0.0, z: -0.0 },
        };

        // Apply the pose
        Object.keys(skiingPose).forEach((boneName) => {
          if (skierBones[boneName] && skiingPose[boneName]) {
            const pose = skiingPose[boneName];
            boneParams[boneName] = {
              x: pose.x || 0,
              y: pose.y || 0,
              z: pose.z || 0,
            };

            // Update the bone rotation
            updateBoneRotation(boneName);

            // Update UI sliders if they exist
            ["X", "Y", "Z"].forEach((axis) => {
              const inputId = `bone_${boneName}_${axis}`;
              const spanId = `val_bone_${boneName}_${axis}`;
              const input = document.getElementById(inputId);
              const span = document.getElementById(spanId);

              if (input && span) {
                const val = boneParams[boneName][axis.toLowerCase()];
                input.value = val;
                span.textContent = val.toFixed(2);
              }
            });
          }
        });

        console.log("Skiing pose applied!");
      }

      function updateBoneRotation(boneName) {
        if (skierBones[boneName] && boneParams[boneName]) {
          const bone = skierBones[boneName];
          const params = boneParams[boneName];

          // Create Euler rotation from individual axis rotations
          const euler = new THREE.Euler(params.x, params.y, params.z, "XYZ");

          // Apply rotation (using quaternion for better bone manipulation)
          bone.quaternion.setFromEuler(euler);

          // Update skeleton if it exists
          if (
            skierModel &&
            skierModel.children[0] &&
            skierModel.children[0].skeleton
          ) {
            skierModel.children[0].skeleton.update();
          }
        }
      }

      function updateSkierDisplay() {
        document.getElementById("valSkierScale").innerText =
          skierParams.scale.toFixed(1);
        document.getElementById("valSkierX").innerText =
          skierParams.posX.toFixed(2);
        document.getElementById("valSkierY").innerText =
          skierParams.posY.toFixed(2);
        document.getElementById("valSkierZ").innerText =
          skierParams.posZ.toFixed(2);
        document.getElementById("valSkierRotX").innerText =
          skierParams.rotX.toFixed(2);
        document.getElementById("valSkierRotY").innerText =
          skierParams.rotY.toFixed(2);
        document.getElementById("valSkierRotZ").innerText =
          skierParams.rotZ.toFixed(2);

        const txt = `
skierModel.scale.set(${skierParams.scale.toFixed(
          1
        )}, ${skierParams.scale.toFixed(1)}, ${skierParams.scale.toFixed(
          1
        )});<br>
skierModel.position.set(${skierParams.posX.toFixed(
          2
        )}, ${skierParams.posY.toFixed(2)}, ${skierParams.posZ.toFixed(2)});<br>
skierModel.rotation.set(${skierParams.rotX.toFixed(
          2
        )}, ${skierParams.rotY.toFixed(2)}, ${skierParams.rotZ.toFixed(2)});
        `;
        document.getElementById("skier-readout").innerHTML = txt;
      }

      function createPlayer() {
        playerGroup = new THREE.Group();
        playerGroup.position.set(0, CONFIG.worldRadius, 0);
        scene.add(playerGroup);
        player = playerGroup;

        // Load the GLB model
        const loader = new THREE.GLTFLoader();
        loader.load(
          "/assets/models/skier_v1.glb",
          (gltf) => {
            skierModel = gltf.scene;

            // Center the model and position it on the ground (base positioning)
            const box = new THREE.Box3().setFromObject(skierModel);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            // Center horizontally but keep feet on ground (base offset)
            skierBaseOffset.x = -center.x;
            skierBaseOffset.y = -box.min.y;
            skierBaseOffset.z = -center.z;

            // Apply user-controlled transforms
            skierModel.scale.set(
              skierParams.scale,
              skierParams.scale,
              skierParams.scale
            );
            skierModel.position.x = skierBaseOffset.x + skierParams.posX;
            skierModel.position.y = skierBaseOffset.y + skierParams.posY;
            skierModel.position.z = skierBaseOffset.z + skierParams.posZ;
            skierModel.rotation.x = skierParams.rotX;
            skierModel.rotation.y = skierParams.rotY;
            skierModel.rotation.z = skierParams.rotZ;

            // Enable shadows and brighten materials
            skierModel.traverse((child) => {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;

                // Fix dark materials - make them brighter and more responsive to light
                if (child.material) {
                  // If it's a PBR material, adjust it
                  if (child.material.metalness !== undefined) {
                    child.material.metalness = Math.min(
                      child.material.metalness,
                      0.1
                    );
                    child.material.roughness = Math.max(
                      child.material.roughness,
                      0.8
                    );
                  }

                  // Brighten the material
                  if (child.material.color) {
                    child.material.color.multiplyScalar(1.5);
                  }

                  // Add emissive for slight self-illumination
                  if (child.material.emissive) {
                    child.material.emissive.setRGB(0.1, 0.1, 0.1);
                    child.material.emissiveIntensity = 0.3;
                  }

                  child.material.needsUpdate = true;
                }
              }

              // Store bones for manipulation
              if (child.isBone || child.type === "Bone") {
                skierBones[child.name] = child;
                console.log("Found bone:", child.name);
              }
            });

            // Also check for skeleton in the scene
            if (gltf.scene.children[0] && gltf.scene.children[0].skeleton) {
              const skeleton = gltf.scene.children[0].skeleton;
              skeleton.bones.forEach((bone) => {
                skierBones[bone.name] = bone;
                console.log("Found skeleton bone:", bone.name);
              });
            }

            // Log all found bones
            const boneNames = Object.keys(skierBones);
            console.log("Total bones found:", boneNames.length);
            console.log("Bone names:", boneNames);

            // Setup bone controls if bones exist
            if (boneNames.length > 0) {
              // Initialize bone rotations from current bone states
              boneNames.forEach((boneName) => {
                const bone = skierBones[boneName];
                if (bone) {
                  const euler = new THREE.Euler().setFromQuaternion(
                    bone.quaternion
                  );
                  boneParams[boneName] = {
                    x: euler.x,
                    y: euler.y,
                    z: euler.z,
                  };
                }
              });
              setupBoneControls(boneNames);

              // Apply skiing pose automatically on load
              applySkiingPose();
            } else {
              console.log("No bones found - model may not be rigged");
            }

            playerGroup.add(skierModel);

            // Add a dedicated light to illuminate the player
            const playerLight = new THREE.PointLight(0xffffff, 1.5, 20);
            playerLight.position.set(0, 5, 3);
            playerGroup.add(playerLight);

            // Setup animations if present
            if (gltf.animations && gltf.animations.length > 0) {
              mixer = new THREE.AnimationMixer(skierModel);

              // Log available animations
              console.log(
                "Available animations:",
                gltf.animations.map((a) => a.name)
              );

              // Play the first animation by default (usually idle or ski)
              const action = mixer.clipAction(gltf.animations[0]);
              action.play();
            }

            console.log("Skier model loaded! Size:", size);
            updateSkierDisplay();
          },
          (progress) => {
            console.log(
              "Loading skier:",
              ((progress.loaded / progress.total) * 100).toFixed(1) + "%"
            );
          },
          (error) => {
            console.error("Error loading skier model:", error);
            // Fallback to procedural skier if model fails to load
            createFallbackPlayer();
          }
        );
      }

      // Fallback procedural player in case GLB fails to load
      function createFallbackPlayer() {
        const skinMat = new THREE.MeshLambertMaterial({ color: 0xffccaa });
        const suitMat = new THREE.MeshLambertMaterial({ color: 0xe67e22 });
        const skiMat = new THREE.MeshLambertMaterial({ color: 0x333333 });

        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.5, 0.3, 1.5, 8),
          suitMat
        );
        body.position.y = 0.75;
        body.castShadow = true;
        playerGroup.add(body);

        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.4, 16, 16),
          skinMat
        );
        head.position.y = 1.7;
        head.castShadow = true;
        playerGroup.add(head);

        const skiGeo = new THREE.BoxGeometry(0.3, 0.1, 2.5);
        const skiL = new THREE.Mesh(skiGeo, skiMat);
        skiL.position.set(-0.4, 0.05, 0);
        skiL.castShadow = true;
        playerGroup.add(skiL);

        const skiR = new THREE.Mesh(skiGeo, skiMat);
        skiR.position.set(0.4, 0.05, 0);
        skiR.castShadow = true;
        playerGroup.add(skiR);
      }

      function createParticleSystem() {
        const particleCount = 250;
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = [];

        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = 0;
          positions[i * 3 + 1] = -500;
          positions[i * 3 + 2] = 0;
          velocities.push({
            x: (Math.random() - 0.5) * 0.2,
            y: Math.random() * 0.2,
            z: -Math.random() * 0.5,
          });
        }

        particles.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );

        const pMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.8,
          map: getParticleTexture(),
          transparent: true,
          opacity: 0.8,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });

        particlesSystem = new THREE.Points(particles, pMaterial);
        scene.add(particlesSystem);
        particlesSystem.userData = { velocities: velocities };
      }

      function updateParticles() {
        const positions = particlesSystem.geometry.attributes.position.array;
        const velocities = particlesSystem.userData.velocities;

        if (gameActive && currentRotationSpeed > 0.001) {
          const index = Math.floor(Math.random() * 200);
          if (!isJumping) {
            positions[index * 3] = player.position.x + (Math.random() - 0.5);
            positions[index * 3 + 1] = CONFIG.worldRadius;
            positions[index * 3 + 2] = -1.5;
          }
        }

        for (let i = 0; i < 200; i++) {
          positions[i * 3] += velocities[i].x;
          positions[i * 3 + 1] += velocities[i].y;
          positions[i * 3 + 2] += velocities[i].z;

          if (positions[i * 3 + 1] > 0) positions[i * 3 + 1] -= 0.1;
          if (positions[i * 3 + 1] < CONFIG.worldRadius - 5)
            positions[i * 3 + 1] = -500;
        }
        particlesSystem.geometry.attributes.position.needsUpdate = true;
      }

      function placeOnSphere(obj, angleRad, xOffset) {
        const R = CONFIG.worldRadius;
        const y = R * Math.cos(angleRad);
        const z = R * Math.sin(angleRad);

        obj.position.set(xOffset, y, z);
        obj.rotation.x = angleRad;

        worldSphere.add(obj);
      }

      // --- ASSETS ---
      const treeGeo = new THREE.ConeGeometry(1.5, 4, 8);
      const trunkGeo = new THREE.CylinderGeometry(0.4, 0.4, 1, 8);
      const treeMat = new THREE.MeshLambertMaterial({ color: 0x27ae60 });
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5d4037 });
      const snowMat = new THREE.MeshLambertMaterial({ color: 0xffffff });

      function spawnTree(angle, isDecoration = false, laneIndex = 0) {
        const treeGroup = new THREE.Group();

        const leaves = new THREE.Mesh(treeGeo, treeMat);
        leaves.position.y = 2.0;
        leaves.castShadow = true;
        treeGroup.add(leaves);

        const cap = new THREE.Mesh(
          new THREE.ConeGeometry(1.0, 1.5, 8),
          snowMat
        );
        cap.position.y = 3.3;
        treeGroup.add(cap);

        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 0.5;
        treeGroup.add(trunk);

        let xPos;
        if (isDecoration) {
          const side = Math.random() > 0.5 ? 1 : -1;
          xPos = side * (10 + Math.random() * 15);
        } else {
          const lane = laneIndex - 1;
          xPos = lane * CONFIG.laneWidth;
        }

        placeOnSphere(treeGroup, angle, xPos);
        activeObstacles.push({ mesh: treeGroup, angle: angle });
      }

      // NEW SMALLER BARRIER
      const stickGeo = new THREE.CylinderGeometry(0.12, 0.12, 3.0, 8); // Shorter sticks
      const barrierMat = new THREE.MeshLambertMaterial({ color: 0xe74c3c });

      function spawnBarrier(angle, laneIndex) {
        const lane = laneIndex - 1;
        const xPos = lane * CONFIG.laneWidth;

        const group = new THREE.Group();

        const s1 = new THREE.Mesh(stickGeo, barrierMat);
        s1.rotation.z = Math.PI / 4;
        s1.position.y = 0.8; // Lower
        s1.castShadow = true;
        group.add(s1);

        const s2 = new THREE.Mesh(stickGeo, barrierMat);
        s2.rotation.z = -Math.PI / 4;
        s2.position.y = 0.8; // Lower
        s2.castShadow = true;
        group.add(s2);

        placeOnSphere(group, angle, xPos);
        activeBarriers.push({ mesh: group, angle: angle, passed: false });
      }

      // --- NEW: BOUNDARY DECORATIONS (Flags/Fences) ---
      const bFlagPoleGeo = new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8);
      const bFlagCanvasGeo = new THREE.PlaneGeometry(1.2, 0.8);
      const bFlagRedMat = new THREE.MeshLambertMaterial({
        color: 0xe74c3c,
        side: THREE.DoubleSide,
      });
      const bFlagBlueMat = new THREE.MeshLambertMaterial({
        color: 0x3498db,
        side: THREE.DoubleSide,
      });
      const bFenceGeo = new THREE.BoxGeometry(3, 1.5, 0.2);
      const bFenceMat = new THREE.MeshLambertMaterial({ color: 0x8d6e63 });

      function spawnBoundary(angle) {
        boundaryAlternator++;
        const isFence = boundaryAlternator % 4 === 0;

        const leftObj = createBoundaryObject(isFence, true);
        placeOnSphere(leftObj, angle, -9);
        activeBoundaries.push({ mesh: leftObj });

        const rightObj = createBoundaryObject(isFence, false);
        placeOnSphere(rightObj, angle, 9);
        activeBoundaries.push({ mesh: rightObj });
      }

      function createBoundaryObject(isFence, isLeft) {
        const group = new THREE.Group();

        if (isFence) {
          const fence = new THREE.Mesh(bFenceGeo, bFenceMat);
          fence.position.y = 0.75;
          fence.rotation.y = Math.PI / 2;
          fence.castShadow = true;
          group.add(fence);
        } else {
          const isRed = Math.floor(boundaryAlternator / 4) % 2 === 0;

          const pole = new THREE.Mesh(
            bFlagPoleGeo,
            new THREE.MeshLambertMaterial({ color: 0x777777 })
          );
          pole.position.y = 1.25;
          pole.castShadow = true;
          group.add(pole);

          const flag = new THREE.Mesh(
            bFlagCanvasGeo,
            isRed ? bFlagRedMat : bFlagBlueMat
          );
          flag.position.y = 1.8;
          flag.position.x = isLeft ? 0.6 : -0.6;
          group.add(flag);
        }
        return group;
      }

      // --- SPAWN LOGIC ---
      function spawnRow(angle) {
        const rand = Math.random();
        const lanes = [0, 1, 2];
        lanes.sort(() => Math.random() - 0.5);

        if (rand < 0.5) {
          spawnTree(angle, false, lanes[0]);
        } else if (rand < 0.7) {
          spawnTree(angle, false, lanes[0]);
          spawnTree(angle, false, lanes[1]);
        } else if (rand < 0.85) {
          spawnBarrier(angle, lanes[0]);
        } else {
          spawnTree(angle, false, lanes[0]);
          spawnBarrier(angle, lanes[1]);
        }
        // Always spawn a decoration tree further out
        spawnTree(angle, true);
      }

      function animate() {
        requestAnimationFrame(animate);

        // Update animation mixer
        const delta = clock.getDelta();
        if (mixer) {
          mixer.update(delta);
        }

        if (gameActive) update();
        renderer.render(scene, camera);
      }

      function update() {
        const dx = targetX - player.position.x;
        player.position.x += dx * CONFIG.turnSpeed;

        if (isJumping) {
          verticalVelocity -= CONFIG.gravity;
          playerHeight += verticalVelocity;

          if (playerHeight <= 0) {
            playerHeight = 0;
            isJumping = false;
            verticalVelocity = 0;
          }
        }
        player.position.y = CONFIG.worldRadius + playerHeight;

        const leanAmount = isJumping ? 0.05 : 0.15;
        player.rotation.z = -dx * leanAmount;
        if (isJumping) player.rotation.x = -0.5;
        else player.rotation.x = 0;

        worldSphere.rotation.x -= currentRotationSpeed;
        const totalRotation = -worldSphere.rotation.x;

        score += currentRotationSpeed * 100;
        document.getElementById("score").innerText = Math.floor(score);

        checkCollisions();

        // Spawn Obstacles
        if (totalRotation - lastSpawnRotation > CONFIG.spawnInterval) {
          // FIXED SPAWN ANGLE: 0.5 is closer to camera than 1.5.
          // 1.5 was spawning behind the new cleanup threshold.
          const spawnAngle = -worldSphere.rotation.x + 0.5;
          spawnRow(spawnAngle);
          lastSpawnRotation = totalRotation;
        }

        // Spawn Boundaries
        if (totalRotation - lastBoundaryRotation > CONFIG.boundaryInterval) {
          const bAngle = -worldSphere.rotation.x + 0.5;
          spawnBoundary(bAngle);
          lastBoundaryRotation = totalRotation;
        }

        updateParticles();
        cleanupObjects();
      }

      function cleanupObjects() {
        // FIXED CLEANUP: Only remove when they go over horizon (Z < -60)
        const cleanupList = [activeObstacles, activeBarriers, activeBoundaries];

        cleanupList.forEach((list) => {
          for (let i = list.length - 1; i >= 0; i--) {
            const obj = list[i];
            const oPos = new THREE.Vector3();
            obj.mesh.getWorldPosition(oPos);

            if (oPos.z < -60) {
              worldSphere.remove(obj.mesh);
              list.splice(i, 1);
            }
          }
        });
      }

      function checkCollisions() {
        const pPos = new THREE.Vector3();
        player.getWorldPosition(pPos);

        // Trees
        for (let i = activeObstacles.length - 1; i >= 0; i--) {
          const obj = activeObstacles[i];
          const oPos = new THREE.Vector3();
          obj.mesh.getWorldPosition(oPos);

          if (Math.abs(oPos.z - pPos.z) < 1.5) {
            if (Math.abs(oPos.x - pPos.x) < 1.5) {
              triggerCrash();
            }
          }
        }

        // Barriers
        for (let i = activeBarriers.length - 1; i >= 0; i--) {
          const obj = activeBarriers[i];
          const oPos = new THREE.Vector3();
          obj.mesh.getWorldPosition(oPos);

          if (!obj.passed && Math.abs(oPos.z - pPos.z) < 1.0) {
            if (Math.abs(oPos.x - pPos.x) < 2.0) {
              // Easier to jump over: > 1.0 height required
              if (playerHeight > 1.0) {
                obj.passed = true;
                showJumpMsg();
                score += 500;
              } else {
                triggerCrash();
              }
            }
          }
        }
      }

      function triggerCrash() {
        const overlay = document.getElementById("crash-overlay");
        overlay.style.opacity = 0.5;
        setTimeout(() => {
          overlay.style.opacity = 0;
        }, 100);
      }

      function showJumpMsg() {
        const msg = document.getElementById("jump-msg");
        msg.style.opacity = 1;
        msg.style.top = "30%";
        setTimeout(() => {
          msg.style.opacity = 0;
          msg.style.top = "40%";
        }, 500);
      }

      function resetGame() {
        activeObstacles.forEach((o) => worldSphere.remove(o.mesh));
        activeBarriers.forEach((o) => worldSphere.remove(o.mesh));
        activeBoundaries.forEach((o) => worldSphere.remove(o.mesh));
        activeObstacles = [];
        activeBarriers = [];
        activeBoundaries = [];

        player.position.x = 0;
        targetX = 0;
        currentLane = 0;
        score = 0;
        currentRotationSpeed = CONFIG.baseSpeed;
        worldSphere.rotation.x = 0;
        lastSpawnRotation = 0;
        lastBoundaryRotation = 0;

        for (let i = 0; i < 30; i++) {
          let angle = 0.5 - i * 0.05;
          spawnTree(angle, true);
          spawnBoundary(angle);
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function moveLane(direction) {
        if (!gameActive) return;
        currentLane += direction;
        if (currentLane < -1) currentLane = -1;
        if (currentLane > 1) currentLane = 1;
        targetX = currentLane * CONFIG.laneWidth;
      }

      function jump() {
        if (!gameActive) return;
        if (!isJumping) {
          isJumping = true;
          verticalVelocity = CONFIG.jumpStrength;
        }
      }

      function onKeyDown(event) {
        if (event.key === "ArrowLeft" || event.key === "a") moveLane(-1);
        if (event.key === "ArrowRight" || event.key === "d") moveLane(1);
        if (event.key === "ArrowUp" || event.key === " " || event.key === "w")
          jump();
      }

      function setupSwipeControls() {
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        document.addEventListener(
          "touchstart",
          (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
          },
          { passive: false }
        );

        document.addEventListener(
          "touchend",
          (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
          },
          { passive: false }
        );

        function handleSwipe() {
          const dx = touchEndX - touchStartX;
          const dy = touchEndY - touchStartY;

          if (Math.abs(dx) > Math.abs(dy)) {
            if (Math.abs(dx) > 40) {
              if (dx < 0) moveLane(-1);
              else moveLane(1);
            }
          } else {
            if (dy < -40) {
              jump();
            }
          }
        }
      }

      init();
    </script>
  </body>
</html>
